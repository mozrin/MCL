I am writing a interpreted language in cpp ... this is the code so far.
Do not put comments in my code.
Do not output files that have not changed.
The current issue is below.
I want to modify the main to run more than one file. Specifically ... I want to be able to fun *.nv or test/*.nv

DO NOT PUT ANY COMMENTS IN MY CODE!
ONLY GIVE ME FILES THAT HAVE CHANGED!
DO NOT WRITE CODE UNLESS I ASK!
--- Folder Structure ---

/nirvana/prep_ai/../code/
├── bin/
└── src/
    ├── core/
    └── extensions/
        ├── abs/
        ├── sqrt/
        └── uppercase/

8 directories, 0 files

--- Baseline File Contents ---

# /nirvana/prep_ai/../code/bin/main.nv # NOT PART OF CODE DON'T ECHO IT EVER #

echo "--- Initial setup and String Concatenation ---";

$my_variable = "Hello from main.nv!";
$frequency = " ... most of the time.";
$part1 = "We are ";
$part2 = "cooool!";

echo $my_variable;
echo "Lexer, Parser, and Evaluator are working.";
echo $part1 . $part2 . $frequency;
echo ("This is a grouped " . "string literal concatenation.");
echo ($part1 . $part2) . " very " . "much!";
echo "Nested parentheses " . ("should " . ("work."));

$complex_expression = ($my_variable . " " . "Testing Concatenation") . $frequency;
echo $complex_expression;

echo "--- Number Types: Integer (long long) and Number (double) ---";

$integer1 = 10;
$integer2 = 3;
$neg_integer = -5;

$double1 = 10.5;
$double2 = 2.5;
$long_decimal = 5.123456789;
$small_decimal = 0.0001;

echo "Integer1: " . $integer1;
echo "Double1: " . $double1;
echo "Long Decimal: " . $long_decimal;

echo "--- Integer Arithmetic Operations ---";
echo "10 + 3 = " . ($integer1 + $integer2);
echo "10 - 3 = " . ($integer1 - $integer2);
echo "10 * -5 = " . ($integer1 * $neg_integer);
echo "10 / 3 (integer division) = " . ($integer1 / $integer2);
echo "-5 / 3 (integer division) = " . ($neg_integer / $integer2);

echo "--- Double Arithmetic Operations ---";
echo "10.5 + 2.5 = " . ($double1 + $double2);
echo "10.5 - 2.5 = " . ($double1 - $double2);
echo "10.5 * 5.123456789 = " . ($double1 * $long_decimal);
echo "10.5 / 2.5 = " . ($double1 / $double2);
echo "5.123456789 / 0.0001 = " . ($long_decimal / $small_decimal);

echo "--- Mixed Type Arithmetic (promotes to double) ---";
echo "10 (int) + 2.5 (double) = " . ($integer1 + $double2);
echo "10.5 (double) - 3 (int) = " . ($double1 - $integer2);
echo "10 (int) * 5.123456789 (double) = " . ($integer1 * $long_decimal);
echo "10.5 (double) / 3 (int) = " . ($double1 / $integer2);

echo "--- Order of Operations Mixed Types ---";
echo "(10 + 2.5) * 3 = " . (($integer1 + $double2) * $integer2);
echo "10 + 2.5 * 3 = " . ($integer1 + $double2 * $integer2);
echo "10 / 3.0 = " . (10 / 3.0); 

echo "--- Boolean Type and Logical Operations ---";
$bool_true = true;
$bool_false = false;

echo "bool_true: " . $bool_true;
echo "bool_false: " . $bool_false;

echo "true and false = " . ($bool_true and $bool_false);
echo "true or false = " . ($bool_true or $bool_false);
echo "not true = " . (not $bool_true);
echo "not false = " . (not $bool_false);

echo "--- Logical Operations with Numbers (0/0.0 is false, non-zero is true) ---";
echo "10 and 0 = " . (10 and 0);
echo "0.0 and 5.5 = " . (0.0 and 5.5);
echo "10 and 5.5 = " . (10 and 5.5);
echo "not 10 = " . (not 10);
echo "not 0 = " . (not 0);
echo "not 5.5 = " . (not 5.5);
echo "not 0.0 = " . (not 0.0);

echo "--- Unary Operators on Different Types ---";
echo "-integer1 = " . -$integer1;
echo "-double1 = " . -$double1;
echo "-bool_true = " . -$bool_true; 
echo "-bool_false = " . -$bool_false; 

echo "--- Comparison Operators (Type promotion for numbers) ---";
echo "10 > 5.5 = " . ($integer1 > $long_decimal);
echo "10 >= 10 = " . ($integer1 >= 10);
echo "10.5 < 10 = " . ($double1 < $integer1);
echo "10.5 <= 10.5 = " . ($double1 <= 10.5);

echo "10 == 10 = " . ($integer1 == 10);
echo "10.0 == 10.0 = " . (10.0 == 10.0);
echo "10 == 10.0 (int vs double) = " . ($integer1 == 10.0);
echo "10.0 != 5.0 = " . ($double1 != 5.0);
echo "10 != 5 (int) = " . ($integer1 != 5);

echo "true == 1 = " . ($bool_true == 1);
echo "false == 0 = " . ($bool_false == 0);
echo "true != 0 = " . ($bool_true != 0);
echo "false != 1 = " . ($bool_false != 1);
echo "true == 1.0 = " . ($bool_true == 1.0);
echo "false == 0.0 = " . ($bool_false == 0.0);

echo "--- String Comparisons ---";
echo "\"hello\" == \"world\" = " . ("hello" == "world");
echo "\"hello\" != \"world\" = " . ("hello" != "world");
echo "\"hello\" == \"hello\" = " . ("hello" == "hello");

echo "--- Mixed Logical and Comparison Operators ---";
echo "((10 > 5) and (2.5 < 10.0)) or (3 == 5) = " . (($integer1 > 5 and $double2 < 10.0) or ($integer2 == 5));
echo "not ((10 < 0) or (5.123 == 5.123)) = " . (not ($integer1 < 0 or $long_decimal == 5.123));

echo "--- Type Conversion in Concatenation ---";
echo "Value of integer1: " . $integer1;
echo "Value of double1: " . $double1;
echo "Value of bool_true: " . $bool_true;
echo "123 (int) . \" \" . 456 (int) = " . (123 . " " . 456);
echo "true (bool) . \" and \" . false (bool) = " . ($bool_true . " and " . $bool_false);
echo "12.34 (double) . \" is a double\" = " . (12.34 . " is a double");

echo "--- Complex Expression Order of Operations ---";
echo "(3*3)/3-1*4+2*2 = " . (3*3)/3-1*4+2*2;
echo "(3.0*3)/3-1*4.0+2*2.0 = " . (3.0*3)/3-1*4.0+2*2.0;

echo "--- Extension Function: abs() ---";
echo "abs(10) = " . abs(10);
echo "abs(-10) = " . abs(-10);
echo "abs(5.5) = " . abs(5.5);
echo "abs(-5.5) = " . abs(-5.5);
$val_to_abs = -123.45;
echo "abs(" . $val_to_abs . ") = " . abs($val_to_abs);

echo "--- Extension Function: sqrt() ---";
echo "sqrt(9) = " . sqrt(9);
echo "sqrt(25.0) = " . sqrt(25.0);
echo "sqrt(2) = " . sqrt(2);
$val_to_sqrt = 144;
echo "sqrt(" . $val_to_sqrt . ") = " . sqrt($val_to_sqrt);

echo "--- Extension Function: uppercase() ---";
$test_string_1 = "hello world";
$test_string_2 = "this is a Test String with numb3rs and symbols!@#";
$test_string_4 = "already UPpER and lOwER";

echo "Default (MCL_UPPERCASE_EVERYTHING):";
echo "  uppercase(\"" . $test_string_1 . "\") = " . uppercase($test_string_1);
echo "  uppercase(\"" . $test_string_2 . "\") = " . uppercase($test_string_2);

echo "MCL_UPPERCASE_EVERYTHING:";
echo "  uppercase(\"" . $test_string_1 . "\", MCL_UPPERCASE_EVERYTHING) = " . uppercase($test_string_1, MCL_UPPERCASE_EVERYTHING);
echo "  uppercase(\"" . $test_string_2 . "\", MCL_UPPERCASE_EVERYTHING) = " . uppercase($test_string_2, MCL_UPPERCASE_EVERYTHING);

echo "MCL_UPPERCASE_TITLE:";
echo "  uppercase(\"" . $test_string_1 . "\", MCL_UPPERCASE_TITLE) = " . uppercase($test_string_1, MCL_UPPERCASE_TITLE);
echo "  uppercase(\"" . $test_string_2 . "\", MCL_UPPERCASE_TITLE) = " . uppercase($test_string_2, MCL_UPPERCASE_TITLE);
echo "  uppercase(\"another-example_string\", MCL_UPPERCASE_TITLE) = " . uppercase("another-example_string", MCL_UPPERCASE_TITLE);

echo "MCL_UPPERCASE_FIRST:";
echo "  uppercase(\"" . $test_string_1 . "\", MCL_UPPERCASE_FIRST) = " . uppercase($test_string_1, MCL_UPPERCASE_FIRST);
echo "  uppercase(\"" . $test_string_2 . "\", MCL_UPPERCASE_FIRST) = " . uppercase($test_string_2, MCL_UPPERCASE_FIRST);
echo "  uppercase(\" already capitalized\", MCL_UPPERCASE_FIRST) = " . uppercase(" already capitalized", MCL_UPPERCASE_FIRST);

echo "MCL_UPPERCASE_ALTERNATING:";
echo "  uppercase(\"" . $test_string_1 . "\", MCL_UPPERCASE_ALTERNATING) = " . uppercase($test_string_1, MCL_UPPERCASE_ALTERNATING);
echo "  uppercase(\"" . $test_string_2 . "\", MCL_UPPERCASE_ALTERNATING) = " . uppercase($test_string_2, MCL_UPPERCASE_ALTERNATING);
echo "  uppercase(\"" . $test_string_4 . "\", MCL_UPPERCASE_ALTERNATING) = " . uppercase($test_string_4, MCL_UPPERCASE_ALTERNATING);

echo "MCL_UPPERCASE_TOGGLE:";
echo "  uppercase(\"" . $test_string_1 . "\", MCL_UPPERCASE_TOGGLE) = " . uppercase($test_string_1, MCL_UPPERCASE_TOGGLE);
echo "  uppercase(\"" . $test_string_2 . "\", MCL_UPPERCASE_TOGGLE) = " . uppercase($test_string_2, MCL_UPPERCASE_TOGGLE);
echo "  uppercase(\"" . $test_string_4 . "\", MCL_UPPERCASE_TOGGLE) = " . uppercase($test_string_4, MCL_UPPERCASE_TOGGLE);

echo "--- All features tested and extensions loaded. ---";
# /nirvana/prep_ai/../code/src/extensions/uppercase/uppercase.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "uppercase.h"
#include "../../core/constants.h"
#include <cmath>
#include <stdexcept>
#include <variant>
#include <string>
#include <cctype>
#include <sstream>

char get_toupper(char c) { return static_cast<char>(std::toupper(static_cast<unsigned char>(c))); }
char get_tolower(char c) { return static_cast<char>(std::tolower(static_cast<unsigned char>(c))); }
bool is_alpha(char c) { return static_cast<bool>(std::isalpha(static_cast<unsigned char>(c))); }
bool is_space(char c) { return static_cast<bool>(std::isspace(static_cast<unsigned char>(c))); }
bool is_alnum(char c) { return static_cast<bool>(std::isalnum(static_cast<unsigned char>(c))); }
bool is_lower(char c) { return static_cast<bool>(std::islower(static_cast<unsigned char>(c))); }
bool is_upper(char c) { return static_cast<bool>(std::isupper(static_cast<unsigned char>(c))); }

Value nirvana_uppercase(const std::vector<Value> &args)
{
if (args.empty() || args.size() > 2)
{
throw std::runtime_error("Function 'uppercase' expects 1 or 2 arguments: uppercase(string $value, int $technique=MCL_UPPERCASE_EVERYTHING).");
}

std::string input_string;
if (std::holds_alternative<std::string>(args[0]))
{
input_string = std::get<std::string>(args[0]);
}
else
{
std::stringstream ss;
ss << "Function 'uppercase': Argument 1 ($value) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

long long technique = MCL_UPPERCASE_EVERYTHING;
if (args.size() == 2)
{
if (std::holds_alternative<long long>(args[1]))
{
technique = std::get<long long>(args[1]);
}
else if (std::holds_alternative<double>(args[1]))
{
double d_tech = std::get<double>(args[1]);
if (d_tech != std::floor(d_tech))
{
std::stringstream ss;
ss << "Function 'uppercase': Argument 2 ($technique) must be an integer, but got " << d_tech << ".";
throw std::runtime_error(ss.str());
}
technique = static_cast<long long>(d_tech);
}
else
{
std::stringstream ss;
ss << "Function 'uppercase': Argument 2 ($technique) must be an integer (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[1]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

if (technique < MCL_UPPERCASE_EVERYTHING || technique > MCL_UPPERCASE_TOGGLE)
{
std::stringstream ss;
ss << "Function 'uppercase': Invalid technique constant " << technique << ".";
throw std::runtime_error(ss.str());
}
}

std::string result_string;
result_string.reserve(input_string.length());

switch (technique)
{
case MCL_UPPERCASE_EVERYTHING:
{
for (char c : input_string)
{
result_string += get_toupper(c);
}
break;
}
case MCL_UPPERCASE_TITLE:
{
bool capitalize_next = true;
for (char c : input_string)
{
if (is_alpha(c))
{
if (capitalize_next)
{
result_string += get_toupper(c);
capitalize_next = false;
}
else
{
result_string += get_tolower(c);
}
}
else
{
result_string += c;
capitalize_next = true;
}
}
break;
}
case MCL_UPPERCASE_FIRST:
{
bool first_char_capitalized = false;
for (char c : input_string)
{
if (!first_char_capitalized && is_alpha(c))
{
result_string += get_toupper(c);
first_char_capitalized = true;
}
else
{
result_string += c;
}
}
break;
}
case MCL_UPPERCASE_ALTERNATING:
{
bool to_upper = true;
for (char c : input_string)
{
if (is_alpha(c))
{
if (to_upper)
{
result_string += get_toupper(c);
}
else
{
result_string += get_tolower(c);
}
to_upper = !to_upper;
}
else
{
result_string += c;
}
}
break;
}
case MCL_UPPERCASE_TOGGLE:
{
for (char c : input_string)
{
if (is_lower(c))
{
result_string += get_toupper(c);
}
else if (is_upper(c))
{
result_string += get_tolower(c);
}
else
{
result_string += c;
}
}
break;
}
default:
{
throw std::runtime_error("Function 'uppercase': Unhandled technique constant. This is an internal error.");
}
}

return result_string;
}

void register_uppercase_extension(Evaluator &eval)
{
eval.registerNativeFunction("uppercase", nirvana_uppercase);
}
# /nirvana/prep_ai/../code/src/extensions/uppercase/uppercase.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef EXTENSION_UPPERCASE_H
#define EXTENSION_UPPERCASE_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value nirvana_uppercase(const std::vector<Value> &args);

void register_uppercase_extension(Evaluator &eval);

#endif
# /nirvana/prep_ai/../code/src/extensions/extensions.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "extensions.h"

void registerAllExtensions(Evaluator &eval)
{
register_abs_extension(eval);
register_sqrt_extension(eval);
register_uppercase_extension(eval);
}
# /nirvana/prep_ai/../code/src/extensions/abs/abs.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_ABS_H
#define EXTENSION_ABS_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value nirvana_abs(const std::vector<Value> &args);

void register_abs_extension(Evaluator &eval);

#endif
# /nirvana/prep_ai/../code/src/extensions/abs/abs.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "abs.h"
#include <cmath>
#include <stdexcept>
#include <variant>

Value nirvana_abs(const std::vector<Value> &args)
{
if (args.size() != 1)
{
throw std::runtime_error("Function 'abs' expects exactly 1 argument: abs(number).");
}

const Value &val = args[0];

if (std::holds_alternative<long long>(val))
{
return std::abs(std::get<long long>(val));
}
else if (std::holds_alternative<double>(val))
{
return std::abs(std::get<double>(val));
}
else
{
throw std::runtime_error("Function 'abs' expects a number (integer or number) argument.");
}
}

void register_abs_extension(Evaluator &eval)
{
eval.registerNativeFunction("abs", nirvana_abs);
}
# /nirvana/prep_ai/../code/src/extensions/extensions.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef ALL_EXTENSIONS_H
#define ALL_EXTENSIONS_H

#include "../core/evaluator.h"

#include "abs/abs.h"
#include "sqrt/sqrt.h"
#include "uppercase/uppercase.h"

void registerAllExtensions(Evaluator &eval);

#endif
# /nirvana/prep_ai/../code/src/extensions/sqrt/sqrt.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "sqrt.h"
#include <cmath>
#include <stdexcept>
#include <variant>

Value nirvana_sqrt(const std::vector<Value> &args)
{
if (args.size() != 1)
{
throw std::runtime_error("Function 'sqrt' expects exactly 1 argument: sqrt(number).");
}

const Value &val = args[0];

if (std::holds_alternative<long long>(val))
{
long long ll_val = std::get<long long>(val);
if (ll_val < 0)
throw std::runtime_error("Function 'sqrt': Argument cannot be negative.");
return std::sqrt(static_cast<double>(ll_val));
}
else if (std::holds_alternative<double>(val))
{
double d_val = std::get<double>(val);
if (d_val < 0.0)
throw std::runtime_error("Function 'sqrt': Argument cannot be negative.");
return std::sqrt(d_val);
}
else
{
throw std::runtime_error("Function 'sqrt' expects a number (integer or number) argument.");
}
}

void register_sqrt_extension(Evaluator &eval)
{
eval.registerNativeFunction("sqrt", nirvana_sqrt);
}
# /nirvana/prep_ai/../code/src/extensions/sqrt/sqrt.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_SQRT_H
#define EXTENSION_SQRT_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value nirvana_sqrt(const std::vector<Value> &args);

void register_sqrt_extension(Evaluator &eval);

#endif
# /nirvana/prep_ai/../code/src/main.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include <iostream>
#include <fstream>
#include <sstream>
#include <memory>
#include <exception>

#include "core/lexer.h"
#include "core/parser.h"
#include "core/ast.h"
#include "core/token.h"
#include "core/evaluator.h"
#include "core/constants.h"
#include "core/debugger.h"
#include "extensions/extensions.h"

int main(int argc, char *argv[])
{
debug_print_message("Nirvana MVI starting (Lexer + Parser + Evaluator)...");

std::string source_code;
std::string input_filename = "main.nv";

if (argc > 1)
{
input_filename = argv[1];
}

std::ifstream file(input_filename);
if (file.is_open())
{
std::stringstream buffer;
buffer << file.rdbuf();
source_code = buffer.str();
file.close();
}
else
{
std::cerr << "Error: Could not open file '" << input_filename << "'.\n";
std::cerr << "Please ensure '" << input_filename << "' exists in the project root,\n";
std::cerr << "or provide a valid path as a command-line argument.\n";
return 1;
}

Lexer lexer(source_code);
Parser parser(lexer);

debug_print_message("Parsing file: '" + input_filename + "'...");

std::unique_ptr<ProgramNode> ast;
try
{
ast = parser.parseProgram();
debug_print_message("Parsing finished.");
}
catch (const std::runtime_error &e)
{
std::cerr << "Parser/Lexer Error during parsing: " << e.what() << std::endl;
return 1;
}
catch (const std::exception &e)
{
std::cerr << "An unexpected error occurred during parsing: " << e.what() << std::endl;
return 1;
}

debug_print_ast_header("Abstract Syntax Tree (AST)");
debug_print_ast_node(ast.get());
debug_print_ast_footer();

debug_print_message("Starting interpretation...");
Evaluator evaluator;
registerAllExtensions(evaluator);

evaluator.registerConstant("MCL_UPPERCASE_EVERYTHING", (long long)MCL_UPPERCASE_EVERYTHING);
evaluator.registerConstant("MCL_UPPERCASE_TITLE", (long long)MCL_UPPERCASE_TITLE);
evaluator.registerConstant("MCL_UPPERCASE_FIRST", (long long)MCL_UPPERCASE_FIRST);
evaluator.registerConstant("MCL_UPPERCASE_ALTERNATING", (long long)MCL_UPPERCASE_ALTERNATING);
evaluator.registerConstant("MCL_UPPERCASE_TOGGLE", (long long)MCL_UPPERCASE_TOGGLE);

try
{
evaluator.interpret(std::move(ast));
debug_print_message("Interpretation finished successfully.");
}
catch (const std::runtime_error &e)
{
std::cerr << "Runtime Error: " << e.what() << std::endl;
return 1;
}
catch (const std::exception &e)
{
std::cerr << "An unexpected error occurred during interpretation: " << e.what() << std::endl;
return 1;
}

debug_print_message("AST generated. Ready for Evaluation (next step).");

return 0;
}
# /nirvana/prep_ai/../code/src/core/lexer.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef LEXER_H
#define LEXER_H

#include <string>
#include <vector>
#include "token.h"

class Lexer
{
private:
std::string source;
int current;
int line;

char peek();
char advance();
char peekNext();
void skipWhitespace();

Token identifierOrKeyword();
Token string();
Token number();

public:
Lexer(std::string source);
Token getNextToken();
};

#endif
# /nirvana/prep_ai/../code/src/core/ast.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef AST_H
#define AST_H

#include <memory>
#include <string>
#include <vector>
#include "token.h"
#include "value.h"

struct ASTNode
{
virtual ~ASTNode() = default;
};

struct StringLiteralExpr : public ASTNode
{
std::string value;
StringLiteralExpr(std::string val) : value(std::move(val)) {}
};

struct NumberLiteralExpr : public ASTNode
{
double value;
NumberLiteralExpr(double val) : value(val) {}
};

struct BooleanLiteralExpr : public ASTNode
{
bool value;
BooleanLiteralExpr(bool val) : value(val) {}
};

struct VariableExpr : public ASTNode
{
std::string name;
VariableExpr(std::string name) : name(std::move(name)) {}
};

struct BinaryOpExpr : public ASTNode
{
TokenType op;
std::unique_ptr<ASTNode> left;
std::unique_ptr<ASTNode> right;

BinaryOpExpr(TokenType op_type, std::unique_ptr<ASTNode> left_expr, std::unique_ptr<ASTNode> right_expr)
: op(op_type), left(std::move(left_expr)), right(std::move(right_expr)) {}
};

struct UnaryOpExpr : public ASTNode
{
TokenType op;
std::unique_ptr<ASTNode> right;

UnaryOpExpr(TokenType op_type, std::unique_ptr<ASTNode> right_expr)
: op(op_type), right(std::move(right_expr)) {}
};

struct CallExpr : public ASTNode
{
std::unique_ptr<ASTNode> callee;
std::vector<std::unique_ptr<ASTNode>> arguments;

CallExpr(std::unique_ptr<ASTNode> callee_expr, std::vector<std::unique_ptr<ASTNode>> args)
: callee(std::move(callee_expr)), arguments(std::move(args)) {}
};

struct AssignmentStatement : public ASTNode
{
std::unique_ptr<VariableExpr> target;
std::unique_ptr<ASTNode> value;
bool is_declaration;

AssignmentStatement(std::unique_ptr<VariableExpr> target_var, std::unique_ptr<ASTNode> assigned_value, bool is_decl = false)
: target(std::move(target_var)), value(std::move(assigned_value)), is_declaration(is_decl) {}
};

struct DeclarationStatement : public ASTNode
{
TokenType declared_type;
std::unique_ptr<VariableExpr> target;
std::unique_ptr<ASTNode> value;

DeclarationStatement(TokenType type, std::unique_ptr<VariableExpr> target_var, std::unique_ptr<ASTNode> initial_value)
: declared_type(type), target(std::move(target_var)), value(std::move(initial_value)) {}
};

struct EchoStatement : public ASTNode
{
std::unique_ptr<ASTNode> expression;

EchoStatement(std::unique_ptr<ASTNode> expr_to_echo) : expression(std::move(expr_to_echo)) {}
};

struct ProgramNode : public ASTNode
{
std::vector<std::unique_ptr<ASTNode>> statements;
ProgramNode() = default;
};

#endif
# /nirvana/prep_ai/../code/src/core/parser.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "parser.h"
#include <iostream>
#include <string>

Parser::Parser(Lexer &lexer) : lexer(lexer), currentToken(lexer.getNextToken())
{
}

void Parser::advance()
{
currentToken = lexer.getNextToken();

if (currentToken.type == TokenType::UNKNOWN)
{
std::cerr << "Parser error: Lexer returned UNKNOWN token: \"" << currentToken.lexeme << "\" at line " << currentToken.line << ". Aborting.\n";
exit(1);
}
}

void Parser::consume(TokenType type)
{
if (currentToken.type == type)
{
advance();
}
else
{
std::cerr << "Parser error: Expected token type " << Token(type, "", 0).toString()
<< " but found " << currentToken.toString() << ".\n";
exit(1);
}
}

std::unique_ptr<ASTNode> Parser::parsePrimaryExpression()
{
if (currentToken.type == TokenType::STRING_LITERAL)
{
std::string value = std::get<std::string>(currentToken.literal);
consume(TokenType::STRING_LITERAL);
return std::make_unique<StringLiteralExpr>(value);
}
else if (currentToken.type == TokenType::NUMBER_LITERAL)
{
double value;
if (std::holds_alternative<long long>(currentToken.literal))
{
value = static_cast<double>(std::get<long long>(currentToken.literal));
}
else
{
value = std::get<double>(currentToken.literal);
}
consume(TokenType::NUMBER_LITERAL);
return std::make_unique<NumberLiteralExpr>(value);
}
else if (currentToken.type == TokenType::TRUE)
{
bool value = std::get<bool>(currentToken.literal);
consume(TokenType::TRUE);
return std::make_unique<BooleanLiteralExpr>(value);
}
else if (currentToken.type == TokenType::FALSE)
{
bool value = std::get<bool>(currentToken.literal);
consume(TokenType::FALSE);
return std::make_unique<BooleanLiteralExpr>(value);
}
else if (currentToken.type == TokenType::IDENTIFIER)
{
std::string name = currentToken.lexeme;
consume(TokenType::IDENTIFIER);
return std::make_unique<VariableExpr>(name);
}
else if (currentToken.type == TokenType::LEFT_PAREN)
{
consume(TokenType::LEFT_PAREN);
std::unique_ptr<ASTNode> expr = parseExpression();
consume(TokenType::RIGHT_PAREN);
return expr;
}

std::cerr << "Parser error at line " << currentToken.line << ": Expected a primary expression (literal, variable, or parenthesized expression), but got "
<< currentToken.toString() << ".\n";
exit(1);
}

std::unique_ptr<ASTNode> Parser::parseCall()
{
std::unique_ptr<ASTNode> expr = parsePrimaryExpression();

while (currentToken.type == TokenType::LEFT_PAREN)
{
consume(TokenType::LEFT_PAREN);
std::vector<std::unique_ptr<ASTNode>> args;
if (currentToken.type != TokenType::RIGHT_PAREN)
{
do
{
args.push_back(parseExpression());
if (currentToken.type == TokenType::COMMA)
{
consume(TokenType::COMMA);
}
else
{
break;
}
} while (true);
}
consume(TokenType::RIGHT_PAREN);
expr = std::make_unique<CallExpr>(std::move(expr), std::move(args));
}
return expr;
}

std::unique_ptr<ASTNode> Parser::parseUnary()
{
if (currentToken.type == TokenType::BANG ||
currentToken.type == TokenType::MINUS ||
currentToken.type == TokenType::NOT)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseUnary();
return std::make_unique<UnaryOpExpr>(op, std::move(right));
}
return parseCall();
}

std::unique_ptr<ASTNode> Parser::parseFactor()
{
std::unique_ptr<ASTNode> left = parseUnary();

while (currentToken.type == TokenType::STAR || currentToken.type == TokenType::SLASH)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseUnary();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseTerm()
{
std::unique_ptr<ASTNode> left = parseFactor();

while (currentToken.type == TokenType::PLUS || currentToken.type == TokenType::MINUS)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseFactor();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseComparison()
{
std::unique_ptr<ASTNode> left = parseTerm();

while (currentToken.type == TokenType::GREATER || currentToken.type == TokenType::GREATER_EQUAL ||
currentToken.type == TokenType::LESS || currentToken.type == TokenType::LESS_EQUAL)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseTerm();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseEquality()
{
std::unique_ptr<ASTNode> left = parseComparison();

while (currentToken.type == TokenType::BANG_EQUAL || currentToken.type == TokenType::EQUAL_EQUAL)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseComparison();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseLogicalAnd()
{
std::unique_ptr<ASTNode> left = parseEquality();

while (currentToken.type == TokenType::AND)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseEquality();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseLogicalOr()
{
std::unique_ptr<ASTNode> left = parseLogicalAnd();

while (currentToken.type == TokenType::OR)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseLogicalAnd();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseConcatenation()
{
std::unique_ptr<ASTNode> left = parseLogicalOr();

while (currentToken.type == TokenType::DOT)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseLogicalOr();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseExpression()
{
return parseConcatenation();
}

std::unique_ptr<ASTNode> Parser::parseStatement()
{
if (currentToken.type == TokenType::ECHO)
{
consume(TokenType::ECHO);
std::unique_ptr<ASTNode> expr = parseExpression();
consume(TokenType::SEMICOLON);
return std::make_unique<EchoStatement>(std::move(expr));
}
else if (currentToken.type == TokenType::PUBLIC)
{
consume(TokenType::PUBLIC);
TokenType declared_type_token = currentToken.type;

if (declared_type_token != TokenType::STRING_KEYWORD &&
declared_type_token != TokenType::INTEGER_KEYWORD &&
declared_type_token != TokenType::NUMBER_KEYWORD &&
declared_type_token != TokenType::BOOLEAN_KEYWORD)
{
std::cerr << "Parser error at line " << currentToken.line << ": Expected a type keyword (string, integer, number, boolean) after 'public', but got "
<< currentToken.toString() << ".\n";
exit(1);
}
consume(declared_type_token);

std::unique_ptr<VariableExpr> var_target = std::make_unique<VariableExpr>(currentToken.lexeme);
consume(TokenType::IDENTIFIER);

std::unique_ptr<ASTNode> value_expr = nullptr;
if (currentToken.type == TokenType::EQUAL)
{
consume(TokenType::EQUAL);
value_expr = parseExpression();
}

consume(TokenType::SEMICOLON);
return std::make_unique<DeclarationStatement>(declared_type_token, std::move(var_target), std::move(value_expr));
}
else if (currentToken.type == TokenType::IDENTIFIER)
{
std::unique_ptr<VariableExpr> var_target = std::make_unique<VariableExpr>(currentToken.lexeme);
consume(TokenType::IDENTIFIER);
consume(TokenType::EQUAL);
std::unique_ptr<ASTNode> value_expr = parseExpression();
consume(TokenType::SEMICOLON);
return std::make_unique<AssignmentStatement>(std::move(var_target), std::move(value_expr), false);
}

std::cerr << "Parser error at line " << currentToken.line << ": Unexpected token at the beginning of a statement: "
<< currentToken.toString() << ".\n";
exit(1);
}

std::unique_ptr<ProgramNode> Parser::parseProgram()
{
auto program = std::make_unique<ProgramNode>();

while (currentToken.type != TokenType::EOF_TOKEN)
{
program->statements.push_back(parseStatement());
}
return program;
}
# /nirvana/prep_ai/../code/src/core/debugger.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef NIRVANA_DEBUGGER_H
#define NIRVANA_DEBUGGER_H

#include <string>
#include <memory>
#include "ast.h"




#ifdef ENABLE_DEBUG_OUTPUT

void debug_print_message(const std::string &msg);
void debug_print_ast_header(const std::string &title);
void debug_print_ast_node(const ASTNode *node, int indent = 0);
void debug_print_ast_footer();

#else

inline void debug_print_message(const std::string &msg) {}
inline void debug_print_ast_header(const std::string &title) {}
inline void debug_print_ast_node(const ASTNode *node, int indent = 0) {}
inline void debug_print_ast_footer() {}

#endif

#endif
# /nirvana/prep_ai/../code/src/core/value.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef VALUE_H
#define VALUE_H

#include <string>
#include <variant>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <cmath>

enum class DeclaredType
{
ANY,
STRING,
INTEGER,
NUMBER,
BOOLEAN
};

inline DeclaredType valueTypeToDeclaredType(const std::variant<std::string, long long, double, bool, std::monostate> &val)
{
if (std::holds_alternative<std::string>(val))
return DeclaredType::STRING;
if (std::holds_alternative<long long>(val))
return DeclaredType::INTEGER;
if (std::holds_alternative<double>(val))
return DeclaredType::NUMBER;
if (std::holds_alternative<bool>(val))
return DeclaredType::BOOLEAN;
return DeclaredType::ANY;
}

using Value = std::variant<std::string, long long, double, bool, std::monostate>;

inline std::ostream &operator<<(std::ostream &os, const Value &val)
{
if (std::holds_alternative<std::string>(val))
{
os << std::get<std::string>(val);
}
else if (std::holds_alternative<long long>(val))
{
os << std::get<long long>(val);
}
else if (std::holds_alternative<double>(val))
{
std::stringstream ss;
ss << std::setprecision(14) << std::get<double>(val);
os << ss.str();
}
else if (std::holds_alternative<bool>(val))
{
os << (std::get<bool>(val) ? "true" : "false");
}
else if (std::holds_alternative<std::monostate>(val))
{
os << "null";
}
return os;
}

#endif
# /nirvana/prep_ai/../code/src/core/constants.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef NIRVANA_CONSTANTS_H
#define NIRVANA_CONSTANTS_H



#define MCL_UPPERCASE_EVERYTHING 1
#define MCL_UPPERCASE_TITLE 2
#define MCL_UPPERCASE_FIRST 3
#define MCL_UPPERCASE_ALTERNATING 4
#define MCL_UPPERCASE_TOGGLE 5

#endif
# /nirvana/prep_ai/../code/src/core/token.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef TOKEN_H
#define TOKEN_H

#include <string>
#include <variant>
#include <utility>
#include <cstdint>

#include "value.h"

enum class TokenType
{
SEMICOLON,
DOT,
EQUAL,
LEFT_PAREN,
RIGHT_PAREN,
PLUS,
MINUS,
STAR,
SLASH,
BANG,
LESS,
GREATER,

BANG_EQUAL,
EQUAL_EQUAL,
LESS_EQUAL,
GREATER_EQUAL,

IDENTIFIER,
STRING_LITERAL,
NUMBER_LITERAL,
TRUE,
FALSE,

ECHO,
AND,
OR,
NOT,

PUBLIC,
STRING_KEYWORD,
INTEGER_KEYWORD,
NUMBER_KEYWORD,
BOOLEAN_KEYWORD,

COMMA,

EOF_TOKEN,
UNKNOWN,
};

inline DeclaredType tokenTypeToDeclaredType(TokenType type)
{
switch (type)
{
case TokenType::STRING_KEYWORD:
return DeclaredType::STRING;
case TokenType::INTEGER_KEYWORD:
return DeclaredType::INTEGER;
case TokenType::NUMBER_KEYWORD:
return DeclaredType::NUMBER;
case TokenType::BOOLEAN_KEYWORD:
return DeclaredType::BOOLEAN;
default:
return DeclaredType::ANY;
}
}

struct Token
{
TokenType type;
std::string lexeme;
std::variant<std::string, long long, double, bool, std::monostate> literal;
int line;

Token(TokenType type, std::string lexeme, std::variant<std::string, long long, double, bool, std::monostate> literal, int line)
: type(type), lexeme(std::move(lexeme)), literal(std::move(literal)), line(line) {}

Token(TokenType type, std::string lexeme, int line)
: type(type), lexeme(std::move(lexeme)), literal(std::monostate{}), line(line) {}

std::string toString() const;
};

#endif
# /nirvana/prep_ai/../code/src/core/debugger.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "debugger.h"
#include <iostream>
#include <string>
#include "token.h"

#ifdef ENABLE_DEBUG_OUTPUT

void printIndent(int indent)
{
for (int i = 0; i < indent; ++i)
{
std::cout << "  ";
}
}

void debug_print_message(const std::string &msg)
{
std::cout << msg << std::endl;
}

void debug_print_ast_header(const std::string &title)
{
std::cout << "\n--- " << title << " ---" << std::endl;
}

void debug_print_ast_node(const ASTNode *node, int indent)
{
if (!node)
{
return;
}

printIndent(indent);

if (auto *prog = dynamic_cast<const ProgramNode *>(node))
{
std::cout << "ProgramNode (" << prog->statements.size() << " statements)\n";
for (const auto &stmt : prog->statements)
{
debug_print_ast_node(stmt.get(), indent + 1);
}
}
else if (auto *decl = dynamic_cast<const DeclarationStatement *>(node))
{
std::cout << "DeclarationStatement (Type: " << Token(decl->declared_type, "", 0).toString() << ", Target: " << decl->target->name << ")\n";
if (decl->value)
{
debug_print_ast_node(decl->value.get(), indent + 1);
}
else
{
printIndent(indent + 1);
std::cout << "Initial Value: None\n";
}
}
else if (auto *assign = dynamic_cast<const AssignmentStatement *>(node))
{
std::cout << "AssignmentStatement (Target: " << assign->target->name << ")\n";
debug_print_ast_node(assign->value.get(), indent + 1);
}
else if (auto *echo = dynamic_cast<const EchoStatement *>(node))
{
std::cout << "EchoStatement\n";
debug_print_ast_node(echo->expression.get(), indent + 1);
}
else if (auto *strLit = dynamic_cast<const StringLiteralExpr *>(node))
{
std::cout << "StringLiteralExpr: \"" << strLit->value << "\"\n";
}
else if (auto *numLit = dynamic_cast<const NumberLiteralExpr *>(node))
{
std::cout << "NumberLiteralExpr: " << numLit->value << "\n";
}
else if (auto *boolLit = dynamic_cast<const BooleanLiteralExpr *>(node))
{
std::cout << "BooleanLiteralExpr: " << (boolLit->value ? "true" : "false") << "\n";
}
else if (auto *var = dynamic_cast<const VariableExpr *>(node))
{
std::cout << "VariableExpr: " << var->name << "\n";
}
else if (auto *binOp = dynamic_cast<const BinaryOpExpr *>(node))
{
std::cout << "BinaryOpExpr (Op: " << Token(binOp->op, "", 0).toString() << ")\n";
debug_print_ast_node(binOp->left.get(), indent + 1);
debug_print_ast_node(binOp->right.get(), indent + 1);
}
else if (auto *unaryOp = dynamic_cast<const UnaryOpExpr *>(node))
{
std::cout << "UnaryOpExpr (Op: " << Token(unaryOp->op, "", 0).toString() << ")\n";
debug_print_ast_node(unaryOp->right.get(), indent + 1);
}
else if (auto *call = dynamic_cast<const CallExpr *>(node))
{
std::cout << "CallExpr\n";
printIndent(indent + 1);
std::cout << "Callee:\n";
debug_print_ast_node(call->callee.get(), indent + 2);
printIndent(indent + 1);
std::cout << "Arguments (" << call->arguments.size() << "):\n";
for (const auto &arg : call->arguments)
{
debug_print_ast_node(arg.get(), indent + 2);
}
}
else
{
std::cout << "Unknown AST Node Type\n";
}
}

void debug_print_ast_footer()
{
std::cout << "----------------------------------\n\n";
}

#endif
# /nirvana/prep_ai/../code/src/core/evaluator.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EVALUATOR_H
#define EVALUATOR_H

#include <string>
#include <memory>
#include <vector>
#include <map>
#include "ast.h"
#include "value.h"
#include <functional>
#include <stdexcept>

using NativeFunction = std::function<Value(const std::vector<Value> &)>;

class Evaluator
{
private:
std::map<std::string, std::pair<Value, DeclaredType>> variables;
std::map<std::string, NativeFunction> nativeFunctions;

Value evaluate(ASTNode *node);
Value evaluateProgramNode(ProgramNode *node);
Value evaluateDeclarationStatement(DeclarationStatement *node);
Value evaluateAssignmentStatement(AssignmentStatement *node);
Value evaluateEchoStatement(EchoStatement *node);
Value evaluateStringLiteralExpr(StringLiteralExpr *node);
Value evaluateNumberLiteralExpr(NumberLiteralExpr *node);
Value evaluateBooleanLiteralExpr(BooleanLiteralExpr *node);
Value evaluateVariableExpr(VariableExpr *node);
Value evaluateBinaryOpExpr(BinaryOpExpr *node);
Value evaluateUnaryOpExpr(UnaryOpExpr *node);
Value evaluateCallExpr(CallExpr *node);

Value performNumericBinaryOp(const Value &left, const Value &right, TokenType op);
Value performBooleanBinaryOp(const Value &left, const Value &right, TokenType op);
bool convertToBool(const Value &val);
void enforceType(const std::string &var_name, DeclaredType declared_type, const Value &assigned_value);

public:
Evaluator();
void registerNativeFunction(const std::string &name, NativeFunction func);
void registerConstant(const std::string &name, Value value);
void interpret(std::unique_ptr<ProgramNode> ast);
};

#endif
# /nirvana/prep_ai/../code/src/core/parser.h # NOT PART OF CODE DON'T ECHO IT EVER #

#ifndef PARSER_H
#define PARSER_H

#include <vector>
#include <string>
#include <memory>
#include "lexer.h"
#include "ast.h"
#include "token.h"

class Parser
{
private:
Lexer &lexer;
Token currentToken;

void advance();
void consume(TokenType type);

std::unique_ptr<ASTNode> parseStatement();
std::unique_ptr<ASTNode> parseExpression();
std::unique_ptr<ASTNode> parseLogicalOr();
std::unique_ptr<ASTNode> parseLogicalAnd();
std::unique_ptr<ASTNode> parseEquality();
std::unique_ptr<ASTNode> parseComparison();
std::unique_ptr<ASTNode> parseTerm();
std::unique_ptr<ASTNode> parseFactor();
std::unique_ptr<ASTNode> parseUnary();
std::unique_ptr<ASTNode> parseCall();
std::unique_ptr<ASTNode> parseConcatenation();
std::unique_ptr<ASTNode> parsePrimaryExpression();

public:
Parser(Lexer &lexer);

std::unique_ptr<ProgramNode> parseProgram();
};

#endif
# /nirvana/prep_ai/../code/src/core/evaluator.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "evaluator.h"
#include <iostream>
#include <stdexcept>
#include <cmath>
#include <sstream>
#include <variant>
#include <limits>

bool Evaluator::convertToBool(const Value &val)
{
return std::visit([](auto &&arg) -> bool
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, std::string>) {
return !arg.empty();
} else if constexpr (std::is_same_v<T, long long>) {
return arg != 0LL;
} else if constexpr (std::is_same_v<T, double>) {
return arg != 0.0;
} else if constexpr (std::is_same_v<T, bool>) {
return arg;
} else if constexpr (std::is_same_v<T, std::monostate>) {
return false;
} else {
throw std::runtime_error("Internal error: convertToBool received unsupported type.");
} }, val);
}

Value Evaluator::performNumericBinaryOp(const Value &left_val, const Value &right_val, TokenType op)
{
long long left_ll = 0;
bool left_is_ll_candidate = false;
if (std::holds_alternative<long long>(left_val))
{
left_ll = std::get<long long>(left_val);
left_is_ll_candidate = true;
}
else if (std::holds_alternative<bool>(left_val))
{
left_ll = std::get<bool>(left_val) ? 1LL : 0LL;
left_is_ll_candidate = true;
}
else if (std::holds_alternative<double>(left_val))
{
left_is_ll_candidate = false;
}

long long right_ll = 0;
bool right_is_ll_candidate = false;
if (std::holds_alternative<long long>(right_val))
{
right_ll = std::get<long long>(right_val);
right_is_ll_candidate = true;
}
else if (std::holds_alternative<bool>(right_val))
{
right_ll = std::get<bool>(right_val) ? 1LL : 0LL;
right_is_ll_candidate = true;
}
else if (std::holds_alternative<double>(right_val))
{
right_is_ll_candidate = false;
}

if (left_is_ll_candidate && right_is_ll_candidate)
{
switch (op)
{
case TokenType::PLUS:
return left_ll + right_ll;
case TokenType::MINUS:
return left_ll - right_ll;
case TokenType::STAR:
return left_ll * right_ll;
case TokenType::SLASH:
if (right_ll == 0LL)
throw std::runtime_error("Runtime error: Integer division by zero.");
return left_ll / right_ll;
default:
break;
}
}

double left_double_val;
if (std::holds_alternative<double>(left_val))
left_double_val = std::get<double>(left_val);
else
left_double_val = static_cast<double>(left_ll);

double right_double_val;
if (std::holds_alternative<double>(right_val))
right_double_val = std::get<double>(right_val);
else
right_double_val = static_cast<double>(right_ll);

switch (op)
{
case TokenType::PLUS:
return left_double_val + right_double_val;
case TokenType::MINUS:
return left_double_val - right_double_val;
case TokenType::STAR:
return left_double_val * right_double_val;
case TokenType::SLASH:
if (right_double_val == 0.0)
throw std::runtime_error("Runtime error: Floating-point division by zero.");
return left_double_val / right_double_val;
case TokenType::GREATER:
return left_double_val > right_double_val;
case TokenType::GREATER_EQUAL:
return left_double_val >= right_double_val;
case TokenType::LESS:
return left_double_val < right_double_val;
case TokenType::LESS_EQUAL:
return left_double_val <= right_double_val;
default:
throw std::runtime_error("Unsupported numeric binary operator.");
}
}

Value Evaluator::performBooleanBinaryOp(const Value &left_val, const Value &right_val, TokenType op)
{
bool left_bool = convertToBool(left_val);
bool right_bool = convertToBool(right_val);

switch (op)
{
case TokenType::AND:
return left_bool && right_bool;
case TokenType::OR:
return left_bool || right_bool;
default:
throw std::runtime_error("Unsupported boolean binary operator.");
}
}

void Evaluator::enforceType(const std::string &var_name, DeclaredType declared_type, const Value &assigned_value)
{
DeclaredType actual_type = valueTypeToDeclaredType(assigned_value);

if (declared_type == DeclaredType::ANY)
{
return;
}

bool type_matches = false;
switch (declared_type)
{
case DeclaredType::STRING:
type_matches = (actual_type == DeclaredType::STRING);
break;
case DeclaredType::INTEGER:
type_matches = (actual_type == DeclaredType::INTEGER || actual_type == DeclaredType::BOOLEAN);
if (actual_type == DeclaredType::NUMBER)
{
double d_val = std::get<double>(assigned_value);
type_matches = (d_val == std::floor(d_val) && d_val >= std::numeric_limits<long long>::min() && d_val <= std::numeric_limits<long long>::max());
}
break;
case DeclaredType::NUMBER:
type_matches = (actual_type == DeclaredType::NUMBER || actual_type == DeclaredType::INTEGER || actual_type == DeclaredType::BOOLEAN);
break;
case DeclaredType::BOOLEAN:
type_matches = (actual_type == DeclaredType::BOOLEAN);
if (actual_type == DeclaredType::INTEGER)
{
long long ll_val = std::get<long long>(assigned_value);
type_matches = (ll_val == 0LL || ll_val == 1LL);
}
break;
default:
throw std::runtime_error("Internal error: Unknown declared type for variable '" + var_name + "'.");
}

if (!type_matches)
{
std::stringstream ss;
ss << "Type mismatch for variable '" << var_name << "'. Expected ";
switch (declared_type)
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown declared type";
break;
}
ss << ", but got value of type ";
switch (actual_type)
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
case DeclaredType::ANY:
ss << "null";
break;
default:
ss << "unknown actual type";
break;
}
throw std::runtime_error(ss.str());
}
}

Evaluator::Evaluator()
{
}

void Evaluator::registerNativeFunction(const std::string &name, NativeFunction func)
{
nativeFunctions[name] = std::move(func);
}

void Evaluator::registerConstant(const std::string &name, Value value)
{
if (variables.count(name))
{
throw std::runtime_error("Internal error: Attempted to re-register existing constant/variable '" + name + "'.");
}

variables[name] = {value, valueTypeToDeclaredType(value)};
}

Value Evaluator::evaluate(ASTNode *node)
{
if (!node)
{
return std::monostate{};
}

if (auto *prog = dynamic_cast<ProgramNode *>(node))
{
return evaluateProgramNode(prog);
}
else if (auto *decl = dynamic_cast<DeclarationStatement *>(node))
{
return evaluateDeclarationStatement(decl);
}
else if (auto *assign = dynamic_cast<AssignmentStatement *>(node))
{
return evaluateAssignmentStatement(assign);
}
else if (auto *echo = dynamic_cast<EchoStatement *>(node))
{
return evaluateEchoStatement(echo);
}
else if (auto *strLit = dynamic_cast<StringLiteralExpr *>(node))
{
return evaluateStringLiteralExpr(strLit);
}
else if (auto *numLit = dynamic_cast<NumberLiteralExpr *>(node))
{
return evaluateNumberLiteralExpr(numLit);
}
else if (auto *boolLit = dynamic_cast<BooleanLiteralExpr *>(node))
{
return evaluateBooleanLiteralExpr(boolLit);
}
else if (auto *var = dynamic_cast<VariableExpr *>(node))
{
return evaluateVariableExpr(var);
}
else if (auto *binOp = dynamic_cast<BinaryOpExpr *>(node))
{
return evaluateBinaryOpExpr(binOp);
}
else if (auto *unaryOp = dynamic_cast<UnaryOpExpr *>(node))
{
return evaluateUnaryOpExpr(unaryOp);
}
else if (auto *call = dynamic_cast<CallExpr *>(node))
{
return evaluateCallExpr(call);
}
else
{
throw std::runtime_error("Unknown AST node type during evaluation.");
}
}

Value Evaluator::evaluateProgramNode(ProgramNode *node)
{
for (const auto &stmt : node->statements)
{
evaluate(stmt.get());
}
return std::monostate{};
}

Value Evaluator::evaluateDeclarationStatement(DeclarationStatement *node)
{
std::string var_name = node->target->name;
DeclaredType declared_type = tokenTypeToDeclaredType(node->declared_type);

if (variables.count(var_name))
{
throw std::runtime_error("Runtime error: Variable '" + var_name + "' already declared.");
}

Value initial_value_resolved = std::monostate{};
if (node->value)
{
initial_value_resolved = evaluate(node->value.get());
}

enforceType(var_name, declared_type, initial_value_resolved);
variables[var_name] = {initial_value_resolved, declared_type};
return initial_value_resolved;
}

Value Evaluator::evaluateAssignmentStatement(AssignmentStatement *node)
{
Value value = evaluate(node->value.get());
std::string var_name = node->target->name;

auto it = variables.find(var_name);
if (it == variables.end())
{
variables[var_name] = {value, DeclaredType::ANY};
}
else
{
DeclaredType declared_type = it->second.second;
enforceType(var_name, declared_type, value);
it->second.first = value;
}
return value;
}

Value Evaluator::evaluateEchoStatement(EchoStatement *node)
{
Value result = evaluate(node->expression.get());
std::cout << result << std::endl;
return std::monostate{};
}

Value Evaluator::evaluateStringLiteralExpr(StringLiteralExpr *node)
{
return node->value;
}

Value Evaluator::evaluateNumberLiteralExpr(NumberLiteralExpr *node)
{
return node->value;
}

Value Evaluator::evaluateBooleanLiteralExpr(BooleanLiteralExpr *node)
{
return node->value;
}

Value Evaluator::evaluateVariableExpr(VariableExpr *node)
{
auto it = variables.find(node->name);
if (it != variables.end())
{
return it->second.first;
}
else
{
throw std::runtime_error("Undefined variable: " + node->name);
}
}

Value Evaluator::evaluateCallExpr(CallExpr *node)
{
if (auto *callee_var = dynamic_cast<VariableExpr *>(node->callee.get()))
{
std::string function_name = callee_var->name;
auto it = nativeFunctions.find(function_name);
if (it == nativeFunctions.end())
{
throw std::runtime_error("Runtime error: Undefined function '" + function_name + "'.");
}

std::vector<Value> args;
for (const auto &arg_node : node->arguments)
{
args.push_back(evaluate(arg_node.get()));
}

return it->second(args);
}
else
{
throw std::runtime_error("Runtime error: Callee in function call is not a simple identifier.");
}
}

Value Evaluator::evaluateUnaryOpExpr(UnaryOpExpr *node)
{
Value right_val = evaluate(node->right.get());

if (node->op == TokenType::MINUS)
{
return std::visit([](auto &&arg) -> Value
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, long long>) {
return -arg;
} else if constexpr (std::is_same_v<T, double>) {
return -arg;
} else if constexpr (std::is_same_v<T, bool>) {
return static_cast<long long>(arg ? -1 : 0); 
} else {
throw std::runtime_error("Type error: Unary '-' operator can only be applied to numbers.");
} }, right_val);
}
else if (node->op == TokenType::BANG || node->op == TokenType::NOT)
{
return !convertToBool(right_val);
}
throw std::runtime_error("Unsupported unary operator.");
}

Value Evaluator::evaluateBinaryOpExpr(BinaryOpExpr *node)
{
Value left_val = evaluate(node->left.get());
Value right_val = evaluate(node->right.get());

if (node->op == TokenType::DOT)
{
std::string s_left, s_right;
std::visit([&](auto &&arg)
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, std::string>) {
s_left = arg;
} else {
std::stringstream ss;
ss << arg;
s_left = ss.str();
} }, left_val);
std::visit([&](auto &&arg)
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, std::string>) {
s_right = arg;
} else {
std::stringstream ss;
ss << arg;
s_right = ss.str();
} }, right_val);
return s_left + s_right;
}
else if (node->op == TokenType::PLUS || node->op == TokenType::MINUS ||
node->op == TokenType::STAR || node->op == TokenType::SLASH ||
node->op == TokenType::GREATER || node->op == TokenType::GREATER_EQUAL ||
node->op == TokenType::LESS || node->op == TokenType::LESS_EQUAL)
{

bool left_is_numeric_like = std::holds_alternative<long long>(left_val) || std::holds_alternative<double>(left_val) || std::holds_alternative<bool>(left_val);
bool right_is_numeric_like = std::holds_alternative<long long>(right_val) || std::holds_alternative<double>(right_val) || std::holds_alternative<bool>(right_val);

if (!left_is_numeric_like || !right_is_numeric_like)
{
throw std::runtime_error("Type error: Arithmetic/comparison operators can only be applied to numbers.");
}

return performNumericBinaryOp(left_val, right_val, node->op);
}
else if (node->op == TokenType::EQUAL_EQUAL || node->op == TokenType::BANG_EQUAL)
{

bool are_equal = std::visit([](auto &&l_arg, auto &&r_arg) -> bool
{

using L = std::decay_t<decltype(l_arg)>;
using R = std::decay_t<decltype(r_arg)>;

if constexpr (std::is_same_v<L, R>) {
if constexpr (std::is_same_v<L, std::string>) return l_arg == r_arg;
else if constexpr (std::is_same_v<L, long long>) return l_arg == r_arg;
else if constexpr (std::is_same_v<L, double>) return std::abs(l_arg - r_arg) < 0.000001; 
else if constexpr (std::is_same_v<L, bool>) return l_arg == r_arg;
else if constexpr (std::is_same_v<L, std::monostate>) return true; 
}


else if constexpr (
(std::is_same_v<L, long long> || std::is_same_v<L, double> || std::is_same_v<L, bool>) &&
(std::is_same_v<R, long long> || std::is_same_v<R, double> || std::is_same_v<R, bool>)
) {
double l_double, r_double;
if constexpr (std::is_same_v<L, long long>) l_double = static_cast<double>(l_arg);
else if constexpr (std::is_same_v<L, double>) l_double = l_arg;
else if constexpr (std::is_same_v<L, bool>) l_double = l_arg ? 1.0 : 0.0;
else l_double = 0.0; 

if constexpr (std::is_same_v<R, long long>) r_double = static_cast<double>(r_arg);
else if constexpr (std::is_same_v<R, double>) r_double = r_arg;
else if constexpr (std::is_same_v<R, bool>) r_double = r_arg ? 1.0 : 0.0;
else r_double = 0.0; 

return std::abs(l_double - r_double) < 0.000001;
}


return false; }, left_val, right_val);

return (node->op == TokenType::EQUAL_EQUAL) ? are_equal : !are_equal;
}
else if (node->op == TokenType::AND || node->op == TokenType::OR)
{

return performBooleanBinaryOp(left_val, right_val, node->op);
}

throw std::runtime_error("Unsupported binary operator.");
}

void Evaluator::interpret(std::unique_ptr<ProgramNode> ast)
{
evaluate(ast.get());
}
# /nirvana/prep_ai/../code/src/core/token.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "token.h"
#include <map>
#include <string>
#include <iomanip>
#include <sstream>

static const std::map<TokenType, std::string> tokenTypeNames = {
{TokenType::SEMICOLON, "SEMICOLON"},
{TokenType::DOT, "DOT"},
{TokenType::EQUAL, "EQUAL"},
{TokenType::LEFT_PAREN, "LEFT_PAREN"},
{TokenType::RIGHT_PAREN, "RIGHT_PAREN"},
{TokenType::PLUS, "PLUS"},
{TokenType::MINUS, "MINUS"},
{TokenType::STAR, "STAR"},
{TokenType::SLASH, "SLASH"},
{TokenType::BANG, "BANG"},
{TokenType::LESS, "LESS"},
{TokenType::GREATER, "GREATER"},
{TokenType::BANG_EQUAL, "BANG_EQUAL"},
{TokenType::EQUAL_EQUAL, "EQUAL_EQUAL"},
{TokenType::LESS_EQUAL, "LESS_EQUAL"},
{TokenType::GREATER_EQUAL, "GREATER_EQUAL"},
{TokenType::IDENTIFIER, "IDENTIFIER"},
{TokenType::STRING_LITERAL, "STRING_LITERAL"},
{TokenType::NUMBER_LITERAL, "NUMBER_LITERAL"},
{TokenType::TRUE, "TRUE"},
{TokenType::FALSE, "FALSE"},
{TokenType::ECHO, "ECHO"},
{TokenType::AND, "AND"},
{TokenType::OR, "OR"},
{TokenType::NOT, "NOT"},
{TokenType::PUBLIC, "PUBLIC"},
{TokenType::STRING_KEYWORD, "STRING_KEYWORD"},
{TokenType::INTEGER_KEYWORD, "INTEGER_KEYWORD"},
{TokenType::NUMBER_KEYWORD, "NUMBER_KEYWORD"},
{TokenType::BOOLEAN_KEYWORD, "BOOLEAN_KEYWORD"},
{TokenType::COMMA, "COMMA"},
{TokenType::EOF_TOKEN, "EOF_TOKEN"},
{TokenType::UNKNOWN, "UNKNOWN"},
};

std::string Token::toString() const
{
std::string typeName = tokenTypeNames.count(type) ? tokenTypeNames.at(type) : "UNKNOWN_TYPE";
std::string str = typeName + " (\"" + lexeme + "\")";

if (std::holds_alternative<std::string>(literal))
{
str += " -> \"" + std::get<std::string>(literal) + "\"";
}
else if (std::holds_alternative<long long>(literal))
{
str += " -> " + std::to_string(std::get<long long>(literal));
}
else if (std::holds_alternative<double>(literal))
{
std::stringstream ss;
ss << std::setprecision(14) << std::get<double>(literal);
str += " -> " + ss.str();
}
else if (std::holds_alternative<bool>(literal))
{
str += std::string(" -> ") + (std::get<bool>(literal) ? "true" : "false");
}

str += " at line " + std::to_string(line);

return str;
}
# /nirvana/prep_ai/../code/src/core/lexer.cpp # NOT PART OF CODE DON'T ECHO IT EVER #

#include "lexer.h"
#include <iostream>
#include <cctype>
#include <string>
#include <stdexcept>
#include <map>

static const std::map<std::string, TokenType> keywords = {
{"echo", TokenType::ECHO},
{"true", TokenType::TRUE},
{"false", TokenType::FALSE},
{"and", TokenType::AND},
{"or", TokenType::OR},
{"not", TokenType::NOT},
{"public", TokenType::PUBLIC},
{"string", TokenType::STRING_KEYWORD},
{"integer", TokenType::INTEGER_KEYWORD},
{"number", TokenType::NUMBER_KEYWORD},
{"boolean", TokenType::BOOLEAN_KEYWORD}};

Lexer::Lexer(std::string source) : source(std::move(source)), current(0), line(1) {}

char Lexer::peek()
{
if (current >= source.length())
{
return '\0';
}
return source[current];
}

char Lexer::peekNext()
{
if (current + 1 >= source.length())
{
return '\0';
}
return source[current + 1];
}

char Lexer::advance()
{
char c = '\0';
if (current < source.length())
{
c = source[current++];
if (c == '\n')
{
line++;
}
}
return c;
}

void Lexer::skipWhitespace()
{
while (true)
{
char c = peek();
if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
{
advance();
continue;
}

if (c == '/')
{
if (peekNext() == '/')
{
advance();
advance();
while (peek() != '\n' && peek() != '\0')
{
advance();
}
continue;
}
else if (peekNext() == '*')
{
advance();
advance();
while (!(peek() == '*' && peekNext() == '/') && peek() != '\0')
{
advance();
}
if (peek() != '\0')
{
advance();
advance();
}
continue;
}
}
break;
}
}

Token Lexer::identifierOrKeyword()
{
std::string lexeme;
int startLine = line;

if (peek() == '$')
{
lexeme += advance();
}

while (std::isalnum(peek()) || peek() == '_')
{
lexeme += advance();
}

if (lexeme.empty() || lexeme[0] != '$')
{
auto it = keywords.find(lexeme);
if (it != keywords.end())
{
if (it->second == TokenType::TRUE)
return Token(TokenType::TRUE, lexeme, true, startLine);
if (it->second == TokenType::FALSE)
return Token(TokenType::FALSE, lexeme, false, startLine);
return Token(it->second, lexeme, startLine);
}
}

return Token(TokenType::IDENTIFIER, lexeme, startLine);
}

Token Lexer::string()
{
int startLine = line;
advance();
std::string value;

while (peek() != '"' && peek() != '\0')
{
if (peek() == '\\')
{
advance();
char escaped_char = peek();
if (escaped_char == '\0')
{
std::cerr << "Lexer Error: Unterminated escape sequence in string literal at line " << startLine << ".\n";
return Token(TokenType::UNKNOWN, "", startLine);
}

switch (escaped_char)
{
case '"':
value += '"';
break;
case '\\':
value += '\\';
break;
case 'n':
value += '\n';
break;
case 't':
value += '\t';
break;
default:
std::cerr << "Lexer Warning: Unrecognized escape sequence '\\" << escaped_char << "' in string literal at line " << startLine << ".\n";
value += escaped_char;
break;
}
advance();
}
else
{
value += advance();
}
}

if (peek() == '\0')
{
std::cerr << "Lexer Error: Unterminated string literal at line " << startLine << ".\n";
return Token(TokenType::UNKNOWN, "", startLine);
}

advance();

return Token(TokenType::STRING_LITERAL, "\"" + value + "\"", value, startLine);
}

Token Lexer::number()
{
std::string lexeme;
int startLine = line;
bool has_decimal = false;

while (std::isdigit(peek()))
{
lexeme += advance();
}

if (peek() == '.' && std::isdigit(peekNext()))
{
has_decimal = true;
lexeme += advance();

while (std::isdigit(peek()))
{
lexeme += advance();
}
}

if (has_decimal)
{
try
{
double value = std::stod(lexeme);
return Token(TokenType::NUMBER_LITERAL, lexeme, value, startLine);
}
catch (const std::out_of_range &)
{
std::cerr << "Lexer Error: Number literal out of range: " << lexeme << " at line " << startLine << ".\n";
return Token(TokenType::UNKNOWN, lexeme, startLine);
}
catch (const std::invalid_argument &)
{
std::cerr << "Lexer Error: Invalid number literal: " << lexeme << " at line " << startLine << ".\n";
return Token(TokenType::UNKNOWN, lexeme, startLine);
}
}
else
{
try
{
long long value = std::stoll(lexeme);
return Token(TokenType::NUMBER_LITERAL, lexeme, value, startLine);
}
catch (const std::out_of_range &)
{
std::cerr << "Lexer Error: Integer literal out of range: " << lexeme << " at line " << startLine << ".\n";
return Token(TokenType::UNKNOWN, lexeme, startLine);
}
catch (const std::invalid_argument &)
{
std::cerr << "Lexer Error: Invalid integer literal: " << lexeme << " at line " << startLine << ".\n";
return Token(TokenType::UNKNOWN, lexeme, startLine);
}
}
}

Token Lexer::getNextToken()
{
skipWhitespace();

char c = peek();
int startLine = line;

if (c == '\0')
{
return Token(TokenType::EOF_TOKEN, "", startLine);
}

switch (c)
{
case ';':
advance();
return Token(TokenType::SEMICOLON, ";", startLine);
case '.':
advance();
return Token(TokenType::DOT, ".", startLine);
case '(':
advance();
return Token(TokenType::LEFT_PAREN, "(", startLine);
case ')':
advance();
return Token(TokenType::RIGHT_PAREN, ")", startLine);
case '+':
advance();
return Token(TokenType::PLUS, "+", startLine);
case '-':
advance();
return Token(TokenType::MINUS, "-", startLine);
case '*':
advance();
return Token(TokenType::STAR, "*", startLine);
case '/':
advance();
return Token(TokenType::SLASH, "/", startLine);
case '!':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::BANG_EQUAL, "!=", startLine);
}
return Token(TokenType::BANG, "!", startLine);
}
case '=':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::EQUAL_EQUAL, "==", startLine);
}
return Token(TokenType::EQUAL, "=", startLine);
}
case '<':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::LESS_EQUAL, "<=", startLine);
}
return Token(TokenType::LESS, "<", startLine);
}
case '>':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::GREATER_EQUAL, ">=", startLine);
}
return Token(TokenType::GREATER, ">", startLine);
}
case '"':
return string();
case ',':
advance();
return Token(TokenType::COMMA, ",", startLine);
case '$':
return identifierOrKeyword();
default:
if (std::isalpha(c))
{
return identifierOrKeyword();
}
if (std::isdigit(c))
{
return number();
}

std::cerr << "Lexer Error: Unexpected character '" << c << "' at line " << startLine << ".\n";
advance();
return Token(TokenType::UNKNOWN, std::string(1, c), startLine);
}
}
