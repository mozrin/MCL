I am writing a interpreted language in cpp ... this is the code so far.
Do not put comments in my code.
Do not output files that have not changed.
The current issue is below.
Write me a full, verbose, complete, detailed, awesome

markdown

language reference document for the MCL language so far.

DO NOT PUT ANY COMMENTS IN MY CODE!
ONLY GIVE ME FILES THAT HAVE CHANGED!
DO NOT WRITE CODE UNLESS I ASK!
--- Folder Structure ---

/mcl/.prep_ai/../src/
├── core/
├── extensions/
│   ├── abs/
│   ├── ceiling/
│   ├── contains/
│   ├── floor/
│   ├── max/
│   ├── min/
│   ├── pad/
│   ├── reverse/
│   ├── sqrt/
│   ├── trim/
│   ├── uppercase/
│   └── wrap/
└── helpers/
    └── system/

17 directories, 0 files

--- Baseline File Contents ---

# /mcl/.prep_ai/../src/extensions/pad/pad.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_PAD_H
#define EXTENSION_PAD_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_pad(const std::vector<Value> &args);

void register_pad_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/pad/pad_constants.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef MCL_PAD_CONSTANTS_H
#define MCL_PAD_CONSTANTS_H

#define MCL_PAD_RIGHT 1
#define MCL_PAD_LEFT  2

#define MCL_PAD_STRING_DEFAULT " "

#endif
# /mcl/.prep_ai/../src/extensions/pad/pad.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "pad.h"
#include "../../core/constants.h"
#include <string>
#include <vector>
#include <variant>
#include <stdexcept>
#include <sstream>
#include <algorithm>

Value mcl_pad(const std::vector<Value> &args)
{
if (args.empty() || args.size() > 4)
{
throw std::runtime_error("Function 'pad' expects 2 to 4 arguments: pad(string $str, integer $length, string $pad_string=\" \", integer $pad_type=MCL_PAD_RIGHT).");
}

std::string input_string;
if (std::holds_alternative<std::string>(args[0]))
{
input_string = std::get<std::string>(args[0]);
}
else
{
std::stringstream ss;
ss << "Function 'pad': Argument 1 ($str) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

long long length;
if (std::holds_alternative<long long>(args[1]))
{
length = std::get<long long>(args[1]);
}
else if (std::holds_alternative<double>(args[1]))
{
double d_len = std::get<double>(args[1]);
if (d_len != std::floor(d_len))
{
std::stringstream ss;
ss << "Function 'pad': Argument 2 ($length) must be an integer, but got " << d_len << ".";
throw std::runtime_error(ss.str());
}
length = static_cast<long long>(d_len);
}
else
{
std::stringstream ss;
ss << "Function 'pad': Argument 2 ($length) must be an integer (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[1]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

std::string pad_string_val = " ";
if (args.size() >= 3)
{
if (std::holds_alternative<std::string>(args[2]))
{
pad_string_val = std::get<std::string>(args[2]);
if (pad_string_val.empty())
{
pad_string_val = " ";
}
}
else
{
std::stringstream ss;
ss << "Function 'pad': Argument 3 ($pad_string) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[2]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}
}

long long pad_type = MCL_PAD_RIGHT;
if (args.size() == 4)
{
if (std::holds_alternative<long long>(args[3]))
{
pad_type = std::get<long long>(args[3]);
}
else if (std::holds_alternative<double>(args[3]))
{
double d_type = std::get<double>(args[3]);
if (d_type != std::floor(d_type))
{
std::stringstream ss;
ss << "Function 'pad': Argument 4 ($pad_type) must be an integer, but got " << d_type << ".";
throw std::runtime_error(ss.str());
}
pad_type = static_cast<long long>(d_type);
}
else
{
std::stringstream ss;
ss << "Function 'pad': Argument 4 ($pad_type) must be an integer (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[3]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

if (pad_type != MCL_PAD_LEFT && pad_type != MCL_PAD_RIGHT)
{
std::stringstream ss;
ss << "Function 'pad': Invalid pad type constant " << pad_type << ". Use MCL_PAD_LEFT or MCL_PAD_RIGHT.";
throw std::runtime_error(ss.str());
}
}

size_t input_len = input_string.length();
if (length <= static_cast<long long>(input_len))
{
return input_string;
}

size_t pad_chars_needed = static_cast<size_t>(length - input_len);
char actual_pad_char = pad_string_val[0];
std::string padding_str(pad_chars_needed, actual_pad_char);

if (pad_type == MCL_PAD_RIGHT)
{
return input_string + padding_str;
}
else if (pad_type == MCL_PAD_LEFT)
{
return padding_str + input_string;
}

return input_string;
}

void register_pad_extension(Evaluator &eval)
{
eval.registerNativeFunction("pad", mcl_pad);
}
# /mcl/.prep_ai/../src/extensions/ceiling/ceiling.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_CEILING_H
#define EXTENSION_CEILING_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_ceiling(const std::vector<Value> &args);

void register_ceiling_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/ceiling/ceiling.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "ceiling.h"
#include <cmath>
#include <stdexcept>
#include <variant>

Value mcl_ceiling(const std::vector<Value> &args)
{
if (args.size() != 1)
{
throw std::runtime_error("Function 'ceiling' expects exactly 1 argument: ceiling(number).");
}

const Value &val = args[0];

if (std::holds_alternative<long long>(val))
{
return static_cast<long long>(std::ceil(static_cast<double>(std::get<long long>(val))));
}
else if (std::holds_alternative<double>(val))
{
return std::ceil(std::get<double>(val));
}
else
{
throw std::runtime_error("Function 'ceiling' expects a number (integer or number) argument.");
}
}

void register_ceiling_extension(Evaluator &eval)
{
eval.registerNativeFunction("ceiling", mcl_ceiling);
}
# /mcl/.prep_ai/../src/extensions/uppercase/uppercase.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "uppercase.h"
#include "../../core/constants.h"
#include <cmath>
#include <stdexcept>
#include <variant>
#include <string>
#include <cctype>
#include <sstream>

char get_toupper(char c) { return static_cast<char>(std::toupper(static_cast<unsigned char>(c))); }
char get_tolower(char c) { return static_cast<char>(std::tolower(static_cast<unsigned char>(c))); }
bool is_alpha(char c) { return static_cast<bool>(std::isalpha(static_cast<unsigned char>(c))); }
bool is_space(char c) { return static_cast<bool>(std::isspace(static_cast<unsigned char>(c))); }
bool is_alnum(char c) { return static_cast<bool>(std::isalnum(static_cast<unsigned char>(c))); }
bool is_lower(char c) { return static_cast<bool>(std::islower(static_cast<unsigned char>(c))); }
bool is_upper(char c) { return static_cast<bool>(std::isupper(static_cast<unsigned char>(c))); }

Value mcl_uppercase(const std::vector<Value> &args)
{
if (args.empty() || args.size() > 2)
{
throw std::runtime_error("Function 'uppercase' expects 1 or 2 arguments: uppercase(string $value, int $technique=MCL_UPPERCASE_EVERYTHING).");
}

std::string input_string;
if (std::holds_alternative<std::string>(args[0]))
{
input_string = std::get<std::string>(args[0]);
}
else
{
std::stringstream ss;
ss << "Function 'uppercase': Argument 1 ($value) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

long long technique = MCL_UPPERCASE_EVERYTHING;
if (args.size() == 2)
{
if (std::holds_alternative<long long>(args[1]))
{
technique = std::get<long long>(args[1]);
}
else if (std::holds_alternative<double>(args[1]))
{
double d_tech = std::get<double>(args[1]);
if (d_tech != std::floor(d_tech))
{
std::stringstream ss;
ss << "Function 'uppercase': Argument 2 ($technique) must be an integer, but got " << d_tech << ".";
throw std::runtime_error(ss.str());
}
technique = static_cast<long long>(d_tech);
}
else
{
std::stringstream ss;
ss << "Function 'uppercase': Argument 2 ($technique) must be an integer (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[1]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

if (technique < MCL_UPPERCASE_EVERYTHING || technique > MCL_UPPERCASE_TOGGLE)
{
std::stringstream ss;
ss << "Function 'uppercase': Invalid technique constant " << technique << ".";
throw std::runtime_error(ss.str());
}
}

std::string result_string;
result_string.reserve(input_string.length());

switch (technique)
{
case MCL_UPPERCASE_EVERYTHING:
{
for (char c : input_string)
{
result_string += get_toupper(c);
}
break;
}
case MCL_UPPERCASE_TITLE:
{
bool capitalize_next = true;
for (char c : input_string)
{
if (is_alpha(c))
{
if (capitalize_next)
{
result_string += get_toupper(c);
capitalize_next = false;
}
else
{
result_string += get_tolower(c);
}
}
else
{
result_string += c;
capitalize_next = true;
}
}
break;
}
case MCL_UPPERCASE_FIRST:
{
bool first_char_capitalized = false;
for (char c : input_string)
{
if (!first_char_capitalized && is_alpha(c))
{
result_string += get_toupper(c);
first_char_capitalized = true;
}
else
{
result_string += c;
}
}
break;
}
case MCL_UPPERCASE_ALTERNATING:
{
bool to_upper = true;
for (char c : input_string)
{
if (is_alpha(c))
{
if (to_upper)
{
result_string += get_toupper(c);
}
else
{
result_string += get_tolower(c);
}
to_upper = !to_upper;
}
else
{
result_string += c;
}
}
break;
}
case MCL_UPPERCASE_TOGGLE:
{
for (char c : input_string)
{
if (is_lower(c))
{
result_string += get_toupper(c);
}
else if (is_upper(c))
{
result_string += get_tolower(c);
}
else
{
result_string += c;
}
}
break;
}
default:
{
throw std::runtime_error("Function 'uppercase': Unhandled technique constant. This is an internal error.");
}
}

return result_string;
}

void register_uppercase_extension(Evaluator &eval)
{
eval.registerNativeFunction("uppercase", mcl_uppercase);
}
# /mcl/.prep_ai/../src/extensions/uppercase/uppercase_constants.h # NOT PART OF CODE DON'T ECHO IT EVER #
#define MCL_UPPERCASE_EVERYTHING 1
#define MCL_UPPERCASE_TITLE 2
#define MCL_UPPERCASE_FIRST 3
#define MCL_UPPERCASE_ALTERNATING 4
#define MCL_UPPERCASE_TOGGLE 5
# /mcl/.prep_ai/../src/extensions/uppercase/uppercase.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_UPPERCASE_H
#define EXTENSION_UPPERCASE_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_uppercase(const std::vector<Value> &args);

void register_uppercase_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/extensions.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "extensions.h"

void registerAllExtensions(Evaluator &eval)
{
register_abs_extension(eval);
register_ceiling_extension(eval);
register_contains_extension(eval);
register_floor_extension(eval);
register_max_extension(eval);
register_min_extension(eval);
register_pad_extension(eval);
register_reverse_extension(eval);
register_sqrt_extension(eval);
register_trim_extension(eval);
register_uppercase_extension(eval);
register_wrap_extension(eval);
}
# /mcl/.prep_ai/../src/extensions/abs/abs.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_ABS_H
#define EXTENSION_ABS_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_abs(const std::vector<Value> &args);

void register_abs_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/abs/abs.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "abs.h"
#include <cmath>
#include <stdexcept>
#include <variant>

Value mcl_abs(const std::vector<Value> &args)
{
if (args.size() != 1)
{
throw std::runtime_error("Function 'abs' expects exactly 1 argument: abs(number).");
}

const Value &val = args[0];

if (std::holds_alternative<long long>(val))
{
return std::abs(std::get<long long>(val));
}
else if (std::holds_alternative<double>(val))
{
return std::abs(std::get<double>(val));
}
else
{
throw std::runtime_error("Function 'abs' expects a number (integer or number) argument.");
}
}

void register_abs_extension(Evaluator &eval)
{
eval.registerNativeFunction("abs", mcl_abs);
}
# /mcl/.prep_ai/../src/extensions/extensions.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef ALL_EXTENSIONS_H
#define ALL_EXTENSIONS_H

#include "../core/evaluator.h"

#include "abs/abs.h"
#include "ceiling/ceiling.h"
#include "contains/contains.h"
#include "floor/floor.h"
#include "max/max.h"
#include "min/min.h"
#include "pad/pad.h"
#include "reverse/reverse.h"
#include "sqrt/sqrt.h"
#include "trim/trim.h"
#include "uppercase/uppercase.h"
#include "wrap/wrap.h"

void registerAllExtensions(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/trim/trim.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "trim.h"
#include "../../core/constants.h"
#include <string>
#include <vector>
#include <stdexcept>
#include <variant>
#include <sstream>
#include <cmath>

Value mcl_trim(const std::vector<Value> &args)
{
if (args.empty() || args.size() > 3)
{
throw std::runtime_error("Function 'trim' expects 1 to 3 arguments: trim(string $str, string $characters=\" \\t\\n\\r\\0\\x0B\", int $operation=MCL_TRIM_ENDS).");
}

std::string input_str;
if (std::holds_alternative<std::string>(args[0]))
{
input_str = std::get<std::string>(args[0]);
}
else
{
std::stringstream ss;
ss << "Function 'trim': Argument 1 ($str) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

std::string characters_to_trim = " \t\n\r\0\x0B";
if (args.size() >= 2)
{
if (std::holds_alternative<std::string>(args[1]))
{
characters_to_trim = std::get<std::string>(args[1]);
}
else
{
std::stringstream ss;
ss << "Function 'trim': Argument 2 ($characters) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[1]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}
}

long long operation = MCL_TRIM_ENDS;
if (args.size() == 3)
{
if (std::holds_alternative<long long>(args[2]))
{
operation = std::get<long long>(args[2]);
}
else if (std::holds_alternative<double>(args[2]))
{
double d_op = std::get<double>(args[2]);
if (d_op != std::floor(d_op))
{
std::stringstream ss;
ss << "Function 'trim': Argument 3 ($operation) must be an integer, but got " << d_op << ".";
throw std::runtime_error(ss.str());
}
operation = static_cast<long long>(d_op);
}
else
{
std::stringstream ss;
ss << "Function 'trim': Argument 3 ($operation) must be an integer (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[2]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

if (operation < 0 || (operation & ~MCL_TRIM_ALL) != 0)
{
std::stringstream ss;
ss << "Function 'trim': Invalid operation constant " << operation << ". Valid values are combinations of MCL_TRIM_LEFT (1), MCL_TRIM_RIGHT (2), MCL_TRIM_MIDDLE (4), MCL_TRIM_ENDS (3), MCL_TRIM_ALL (7).";
throw std::runtime_error(ss.str());
}
}

std::string result_str = input_str;

if (operation & MCL_TRIM_LEFT)
{
size_t first_char = result_str.find_first_not_of(characters_to_trim);
if (first_char == std::string::npos)
{
return "";
}
result_str = result_str.substr(first_char);
}

if (operation & MCL_TRIM_RIGHT)
{
size_t last_char = result_str.find_last_not_of(characters_to_trim);
if (last_char == std::string::npos)
{
return "";
}
result_str = result_str.substr(0, last_char + 1);
}

if (operation & MCL_TRIM_MIDDLE)
{
if (!characters_to_trim.empty())
{
std::string temp_str;
temp_str.reserve(result_str.length());
bool in_trim_sequence = false;
for (char c : result_str)
{
if (characters_to_trim.find(c) != std::string::npos)
{
if (!in_trim_sequence)
{
temp_str += c;
in_trim_sequence = true;
}
}
else
{
temp_str += c;
in_trim_sequence = false;
}
}
result_str = temp_str;
}
}

return result_str;
}

void register_trim_extension(Evaluator &eval)
{
eval.registerNativeFunction("trim", mcl_trim);
}
# /mcl/.prep_ai/../src/extensions/trim/trim.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_TRIM_H
#define EXTENSION_TRIM_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_trim(const std::vector<Value> &args);

void register_trim_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/trim/trim_constants.h # NOT PART OF CODE DON'T ECHO IT EVER #
#define MCL_TRIM_LEFT 1
#define MCL_TRIM_RIGHT 2
#define MCL_TRIM_MIDDLE 4
#define MCL_TRIM_ENDS 3
#define MCL_TRIM_ALL 7

#define MCL_TRIM_CHARS_DEFAULT " \t\n\r\0\x0B"
#define MCL_TRIM_CHARS_SPACE " "
# /mcl/.prep_ai/../src/extensions/min/min.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_MIN_H
#define EXTENSION_MIN_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_min(const std::vector<Value> &args);

void register_min_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/min/min.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "min.h"
#include <cmath>
#include <stdexcept>
#include <variant>
#include <sstream>

Value mcl_min(const std::vector<Value> &args)
{
if (args.empty())
{
throw std::runtime_error("Function 'min' expects at least 1 argument.");
}

Value current_min = args[0];

if (!std::holds_alternative<long long>(current_min) && !std::holds_alternative<double>(current_min))
{
std::stringstream ss;
ss << "Function 'min': All arguments must be numbers (integer or number), but argument 1 got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
case DeclaredType::ANY:
ss << "null";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

bool result_is_double = std::holds_alternative<double>(current_min);
double current_min_d = result_is_double ? std::get<double>(current_min) : static_cast<double>(std::get<long long>(current_min));

for (size_t i = 1; i < args.size(); ++i)
{
const Value &next_val = args[i];

double next_val_d;
if (std::holds_alternative<long long>(next_val))
{
next_val_d = static_cast<double>(std::get<long long>(next_val));
}
else if (std::holds_alternative<double>(next_val))
{
next_val_d = std::get<double>(next_val);
result_is_double = true;
}
else
{
std::stringstream ss;
ss << "Function 'min': All arguments must be numbers (integer or number), but argument " << (i + 1) << " got value of type ";
switch (valueTypeToDeclaredType(next_val))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
case DeclaredType::ANY:
ss << "null";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

if (next_val_d < current_min_d)
{
current_min_d = next_val_d;
current_min = next_val;
result_is_double = std::holds_alternative<double>(next_val);
}
else if (next_val_d == current_min_d && std::holds_alternative<double>(next_val))
{
result_is_double = true;
}
}

if (result_is_double && std::holds_alternative<long long>(current_min)) {
return static_cast<double>(std::get<long long>(current_min));
}

return current_min;
}

void register_min_extension(Evaluator &eval)
{
eval.registerNativeFunction("min", mcl_min);
}
# /mcl/.prep_ai/../src/extensions/floor/floor.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_FLOOR_H
#define EXTENSION_FLOOR_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_floor(const std::vector<Value> &args);

void register_floor_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/floor/floor.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "floor.h"
#include <cmath>
#include <stdexcept>
#include <variant>

Value mcl_floor(const std::vector<Value> &args)
{
if (args.size() != 1)
{
throw std::runtime_error("Function 'floor' expects exactly 1 argument: floor(number).");
}

const Value &val = args[0];

if (std::holds_alternative<long long>(val))
{
return static_cast<long long>(std::floor(static_cast<double>(std::get<long long>(val))));
}
else if (std::holds_alternative<double>(val))
{
return std::floor(std::get<double>(val));
}
else
{
throw std::runtime_error("Function 'floor' expects a number (integer or number) argument.");
}
}

void register_floor_extension(Evaluator &eval)
{
eval.registerNativeFunction("floor", mcl_floor);
}
# /mcl/.prep_ai/../src/extensions/max/max.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_MAX_H
#define EXTENSION_MAX_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_max(const std::vector<Value> &args);

void register_max_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/max/max.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "max.h"
#include <cmath>
#include <stdexcept>
#include <variant>
#include <sstream>

Value mcl_max(const std::vector<Value> &args)
{
if (args.empty())
{
throw std::runtime_error("Function 'max' expects at least 1 argument.");
}

Value current_max = args[0];

if (!std::holds_alternative<long long>(current_max) && !std::holds_alternative<double>(current_max))
{
std::stringstream ss;
ss << "Function 'max': All arguments must be numbers (integer or number), but argument 1 got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
case DeclaredType::ANY:
ss << "null";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

bool result_is_double = std::holds_alternative<double>(current_max);
double current_max_d = result_is_double ? std::get<double>(current_max) : static_cast<double>(std::get<long long>(current_max));

for (size_t i = 1; i < args.size(); ++i)
{
const Value &next_val = args[i];

double next_val_d;
if (std::holds_alternative<long long>(next_val))
{
next_val_d = static_cast<double>(std::get<long long>(next_val));
}
else if (std::holds_alternative<double>(next_val))
{
next_val_d = std::get<double>(next_val);
result_is_double = true;
}
else
{
std::stringstream ss;
ss << "Function 'max': All arguments must be numbers (integer or number), but argument " << (i + 1) << " got value of type ";
switch (valueTypeToDeclaredType(next_val))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
case DeclaredType::ANY:
ss << "null";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

if (next_val_d > current_max_d)
{
current_max_d = next_val_d;
current_max = next_val;
result_is_double = std::holds_alternative<double>(next_val);
}
else if (next_val_d == current_max_d && std::holds_alternative<double>(next_val))
{
result_is_double = true;
}
}

if (result_is_double && std::holds_alternative<long long>(current_max)) {
return static_cast<double>(std::get<long long>(current_max));
}

return current_max;
}

void register_max_extension(Evaluator &eval)
{
eval.registerNativeFunction("max", mcl_max);
}
# /mcl/.prep_ai/../src/extensions/sqrt/sqrt.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "sqrt.h"
#include <cmath>
#include <stdexcept>
#include <variant>

Value mcl_sqrt(const std::vector<Value> &args)
{
if (args.size() != 1)
{
throw std::runtime_error("Function 'sqrt' expects exactly 1 argument: sqrt(number).");
}

const Value &val = args[0];

if (std::holds_alternative<long long>(val))
{
long long ll_val = std::get<long long>(val);
if (ll_val < 0)
throw std::runtime_error("Function 'sqrt': Argument cannot be negative.");
return std::sqrt(static_cast<double>(ll_val));
}
else if (std::holds_alternative<double>(val))
{
double d_val = std::get<double>(val);
if (d_val < 0.0)
throw std::runtime_error("Function 'sqrt': Argument cannot be negative.");
return std::sqrt(d_val);
}
else
{
throw std::runtime_error("Function 'sqrt' expects a number (integer or number) argument.");
}
}

void register_sqrt_extension(Evaluator &eval)
{
eval.registerNativeFunction("sqrt", mcl_sqrt);
}
# /mcl/.prep_ai/../src/extensions/sqrt/sqrt.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_SQRT_H
#define EXTENSION_SQRT_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_sqrt(const std::vector<Value> &args);

void register_sqrt_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/wrap/wrap.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_WRAP_H
#define EXTENSION_WRAP_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_wrap(const std::vector<Value> &args);

void register_wrap_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/wrap/wrap.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "wrap.h"
#include "../../core/constants.h"
#include <string>
#include <vector>
#include <variant>
#include <stdexcept>
#include <sstream>

Value mcl_wrap(const std::vector<Value> &args)
{
if (args.empty() || args.size() > 2)
{
throw std::runtime_error("Function 'wrap' expects 1 or 2 arguments: wrap(string $value, string $characters=\"\").");
}

std::string input_string;
if (std::holds_alternative<std::string>(args[0]))
{
input_string = std::get<std::string>(args[0]);
}
else
{
std::stringstream ss;
ss << "Function 'wrap': Argument 1 ($value) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

std::string wrapper_chars = "";
if (args.size() == 2)
{
if (std::holds_alternative<std::string>(args[1]))
{
wrapper_chars = std::get<std::string>(args[1]);
}
else
{
std::stringstream ss;
ss << "Function 'wrap': Argument 2 ($characters) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[1]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}
}

std::string left_wrapper = "";
std::string right_wrapper = "";

size_t pipe_pos = wrapper_chars.find('|');

if (pipe_pos == std::string::npos)
{
left_wrapper = wrapper_chars;
}
else
{
left_wrapper = wrapper_chars.substr(0, pipe_pos);
right_wrapper = wrapper_chars.substr(pipe_pos + 1);
}

std::string result = left_wrapper + input_string + right_wrapper;

return result;
}

void register_wrap_extension(Evaluator &eval)
{
eval.registerNativeFunction("wrap", mcl_wrap);
}
# /mcl/.prep_ai/../src/extensions/wrap/wrap_constants.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef MCL_WRAP_CONSTANTS_H
#define MCL_WRAP_CONSTANTS_H

#define MCL_WRAP_CHARS_DEFAULT "'|'"
#define MCL_WRAP_CHARS_HASHES "#|#"
#define MCL_WRAP_CHARS_PIPES "\\||\\|"

#endif
# /mcl/.prep_ai/../src/extensions/contains/contains.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_CONTAINS_H
#define EXTENSION_CONTAINS_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_contains(const std::vector<Value> &args);

void register_contains_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/extensions/contains/contains.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "contains.h"
#include <string>
#include <vector>
#include <variant>
#include <stdexcept>
#include <sstream>

Value mcl_contains(const std::vector<Value> &args)
{
if (args.size() != 2)
{
throw std::runtime_error("Function 'contains' expects exactly 2 arguments: contains(string $str, string $substring).");
}

std::string str;
if (std::holds_alternative<std::string>(args[0]))
{
str = std::get<std::string>(args[0]);
}
else
{
std::stringstream ss;
ss << "Function 'contains': Argument 1 ($str) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[0]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

std::string substring;
if (std::holds_alternative<std::string>(args[1]))
{
substring = std::get<std::string>(args[1]);
}
else
{
std::stringstream ss;
ss << "Function 'contains': Argument 2 ($substring) must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[1]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

return str.find(substring) != std::string::npos;
}

void register_contains_extension(Evaluator &eval)
{
eval.registerNativeFunction("contains", mcl_contains);
}
# /mcl/.prep_ai/../src/extensions/reverse/reverse.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "reverse.h"
#include <string>
#include <vector>
#include <variant>
#include <stdexcept>
#include <sstream>
#include <algorithm>

Value mcl_reverse(const std::vector<Value> &args)
{
if (args.empty())
{
throw std::runtime_error("Function 'reverse' expects at least 1 argument.");
}

std::string combined_string = "";
for (size_t i = 0; i < args.size(); ++i)
{
if (std::holds_alternative<std::string>(args[i]))
{
combined_string += std::get<std::string>(args[i]);
}
else
{
std::stringstream ss;
ss << "Function 'reverse': Argument " << (i + 1) << " must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[i]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}
}

std::reverse(combined_string.begin(), combined_string.end());

return combined_string;
}

void register_reverse_extension(Evaluator &eval)
{
eval.registerNativeFunction("reverse", mcl_reverse);
}
# /mcl/.prep_ai/../src/extensions/reverse/reverse.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EXTENSION_REVERSE_H
#define EXTENSION_REVERSE_H

#include "../../core/value.h"
#include "../../core/evaluator.h"

Value mcl_reverse(const std::vector<Value> &args);

void register_reverse_extension(Evaluator &eval);

#endif
# /mcl/.prep_ai/../src/main.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include <iostream>
#include <fstream>
#include <sstream>
#include <memory>
#include <exception>
#include <vector>
#include <filesystem>
#include <regex>

#include "core/lexer.h"
#include "core/parser.h"
#include "core/ast.h"
#include "core/token.h"
#include "core/evaluator.h"
#include "core/constants.h"
#include "core/debugger.h"
#include "extensions/extensions.h"
#include "helpers/helpers.h"

namespace fs = std::filesystem;

int process_single_file(const std::string &filename)
{
debug_print_message("Processing file: '" + filename + "'...");

std::string source_code;
std::ifstream file(filename);
if (file.is_open())
{
std::stringstream buffer;
buffer << file.rdbuf();
source_code = buffer.str();
file.close();
}
else
{
std::cerr << "Error: Could not open file '" << filename << "'. Skipping.\n";
return 1;
}

Lexer lexer(source_code);
Parser parser(lexer);

debug_print_message("Parsing file: '" + filename + "'...");

std::unique_ptr<ProgramNode> ast;
try
{
ast = parser.parseProgram();
debug_print_message("Parsing finished for '" + filename + "'.");
}
catch (const std::runtime_error &e)
{
std::cerr << "Parser/Lexer Error in '" << filename << "': " << e.what() << std::endl;
return 1;
}
catch (const std::exception &e)
{
std::cerr << "An unexpected error occurred during parsing '" << filename << "': " << e.what() << std::endl;
return 1;
}

debug_print_ast_header("Abstract Syntax Tree (AST) for " + filename);
debug_print_ast_node(ast.get());
debug_print_ast_footer();

debug_print_message("Starting interpretation for '" + filename + "'...");
Evaluator evaluator;

evaluator.registerConstant("MCL_PAD_RIGHT", (long long)MCL_PAD_RIGHT);
evaluator.registerConstant("MCL_PAD_LEFT", (long long)MCL_PAD_LEFT);
evaluator.registerConstant("MCL_PAD_STRING_DEFAULT", MCL_PAD_STRING_DEFAULT);

evaluator.registerConstant("MCL_UPPERCASE_EVERYTHING", (long long)MCL_UPPERCASE_EVERYTHING);
evaluator.registerConstant("MCL_UPPERCASE_TITLE", (long long)MCL_UPPERCASE_TITLE);
evaluator.registerConstant("MCL_UPPERCASE_FIRST", (long long)MCL_UPPERCASE_FIRST);
evaluator.registerConstant("MCL_UPPERCASE_ALTERNATING", (long long)MCL_UPPERCASE_ALTERNATING);
evaluator.registerConstant("MCL_UPPERCASE_TOGGLE", (long long)MCL_UPPERCASE_TOGGLE);

evaluator.registerConstant("MCL_TRIM_LEFT", (long long)MCL_TRIM_LEFT);
evaluator.registerConstant("MCL_TRIM_RIGHT", (long long)MCL_TRIM_RIGHT);
evaluator.registerConstant("MCL_TRIM_MIDDLE", (long long)MCL_TRIM_MIDDLE);
evaluator.registerConstant("MCL_TRIM_ENDS", (long long)MCL_TRIM_ENDS);
evaluator.registerConstant("MCL_TRIM_ALL", (long long)MCL_TRIM_ALL);
evaluator.registerConstant("MCL_TRIM_CHARS_DEFAULT", MCL_TRIM_CHARS_DEFAULT);

evaluator.registerConstant("MCL_WRAP_CHARS_DEFAULT", MCL_WRAP_CHARS_DEFAULT);
evaluator.registerConstant("MCL_WRAP_CHARS_HASHES", MCL_WRAP_CHARS_HASHES);
evaluator.registerConstant("MCL_WRAP_CHARS_PIPES", MCL_WRAP_CHARS_PIPES);

registerAllExtensions(evaluator);
registerAllHelpers(evaluator);

try
{
evaluator.interpret(std::move(ast));
debug_print_message("Interpretation finished successfully for '" + filename + "'.");
}
catch (const std::runtime_error &e)
{
std::cerr << "Runtime Error in '" << filename << "': " << e.what() << std::endl;
return 1;
}
catch (const std::exception &e)
{
std::cerr << "An unexpected error occurred during interpretation of '" << filename << "': " << e.what() << std::endl;
return 1;
}

debug_print_message("Finished processing '" + filename + "'.");
return 0;
}

std::vector<std::string> get_files_from_pattern(const std::string &pattern_arg)
{
std::vector<std::string> files;
fs::path p(pattern_arg);

bool contains_wildcard = pattern_arg.find('*') != std::string::npos || pattern_arg.find('?') != std::string::npos;

if (contains_wildcard)
{
fs::path directory = p.has_parent_path() ? p.parent_path() : fs::current_path();
std::string filename_pattern_str = p.filename().string();

std::string regex_pattern_str = filename_pattern_str;
regex_pattern_str = std::regex_replace(regex_pattern_str, std::regex("[\\.^$|()\\[\\]{}+?]"), "\\$&");
regex_pattern_str = std::regex_replace(regex_pattern_str, std::regex("\\*"), ".*");
regex_pattern_str = std::regex_replace(regex_pattern_str, std::regex("\\?"), ".");
std::regex file_regex(regex_pattern_str);

if (!fs::exists(directory))
{
std::cerr << "Warning: Directory '" << directory.string() << "' specified in pattern '" << pattern_arg << "' does not exist. Skipping.\n";
return files;
}
if (!fs::is_directory(directory))
{
std::cerr << "Warning: Path '" << directory.string() << "' specified in pattern '" << pattern_arg << "' is not a directory. Skipping.\n";
return files;
}

try
{
for (const auto &entry : fs::directory_iterator(directory))
{
if (entry.is_regular_file())
{
if (std::regex_match(entry.path().filename().string(), file_regex))
{
files.push_back(entry.path().string());
}
}
}
}
catch (const fs::filesystem_error &e)
{
std::cerr << "Filesystem error while iterating directory '" << directory.string() << "': " << e.what() << std::endl;
}
}
else
{
if (fs::exists(p) && fs::is_regular_file(p))
{
files.push_back(pattern_arg);
}
else
{
std::cerr << "Error: File '" << pattern_arg << "' not found or is not a regular file. Skipping.\n";
}
}
return files;
}

int main(int argc, char *argv[])
{
debug_print_message("MCL starting (Lexer + Parser + Evaluator)...");

std::vector<std::string> files_to_run;
int overall_exit_code = 0;

if (argc == 1)
{
files_to_run.push_back("main.nv");
}
else
{
for (int i = 1; i < argc; ++i)
{
std::vector<std::string> matched_files = get_files_from_pattern(argv[i]);
files_to_run.insert(files_to_run.end(), matched_files.begin(), matched_files.end());
}
}

if (files_to_run.empty())
{
std::cerr << "Error: No MCL files found to process based on provided arguments." << std::endl;
return 1;
}

for (const std::string &filename : files_to_run)
{
int file_exit_code = process_single_file(filename);
if (file_exit_code != 0)
{
overall_exit_code = 1;
}
}

debug_print_message("MCL finished.");
return overall_exit_code;
}
# /mcl/.prep_ai/../src/helpers/helpers.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef HELPERS_H
#define HELPERS_H

#include "core/evaluator.h"
#include "core/value.h"
#include "core/token.h"
#include <string>
#include <vector>
#include <map>
#include <variant>
#include <sstream>
#include <cmath>

enum class ParameterKind
{
REQUIRED,
OPTIONAL,
FIXED
};

struct ParameterDefinition
{
ParameterKind kind;
DeclaredType expected_type;
std::string config_value_str;
Value resolved_value;

ParameterDefinition() : kind(ParameterKind::REQUIRED), expected_type(DeclaredType::ANY) {}
};

struct HelperDefinition
{
std::string helper_name;
std::string extension_name;
std::vector<ParameterDefinition> parameters;
};

void registerAllHelpers(Evaluator &eval);

inline std::string get_string_arg(const std::vector<Value> &args, size_t index, const std::string &func_name, const std::string &arg_name)
{
if (index >= args.size())
{
throw std::runtime_error("Function '" + func_name + "': Missing argument " + arg_name + " at index " + std::to_string(index) + ".");
}
if (std::holds_alternative<std::string>(args[index]))
{
return std::get<std::string>(args[index]);
}
std::stringstream ss;
ss << "Function '" << func_name << "': Argument " << arg_name << " must be a string, but got value of type ";
switch (valueTypeToDeclaredType(args[index]))
{
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

inline long long get_integer_arg(const std::vector<Value> &args, size_t index, const std::string &func_name, const std::string &arg_name)
{
if (index >= args.size())
{
throw std::runtime_error("Function '" + func_name + "': Missing argument " + arg_name + " at index " + std::to_string(index) + ".");
}
if (std::holds_alternative<long long>(args[index]))
{
return std::get<long long>(args[index]);
}
else if (std::holds_alternative<double>(args[index]))
{
double d_val = std::get<double>(args[index]);
if (d_val != std::floor(d_val))
{
std::stringstream ss;
ss << "Function '" << func_name << "': Argument " << arg_name << " must be an integer, but got " << d_val << ".";
throw std::runtime_error(ss.str());
}
return static_cast<long long>(d_val);
}
std::stringstream ss;
ss << "Function '" << func_name << "': Argument " << arg_name << " must be an integer (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[index]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

inline Value get_number_arg(const std::vector<Value> &args, size_t index, const std::string &func_name, const std::string &arg_name)
{
if (index >= args.size())
{
throw std::runtime_error("Function '" + func_name + "': Missing argument " + arg_name + " at index " + std::to_string(index) + ".");
}
if (std::holds_alternative<long long>(args[index]) || std::holds_alternative<double>(args[index]))
{
return args[index];
}
std::stringstream ss;
ss << "Function '" << func_name << "': Argument " << arg_name << " must be a number (integer or number), but got value of type ";
switch (valueTypeToDeclaredType(args[index]))
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown";
break;
}
ss << ".";
throw std::runtime_error(ss.str());
}

#endif
# /mcl/.prep_ai/../src/helpers/helpers.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "helpers.h"
#include <fstream>
#include <sstream>
#include <filesystem>
#include <regex>
#include <iostream>
#include <stdexcept>
#include <limits>

namespace fs = std::filesystem;

static Value parseLiteralString(const std::string &s)
{
if (s.length() >= 2 && s.front() == '"' && s.back() == '"')
{
std::string unquoted_s = s.substr(1, s.length() - 2);
std::string result;
result.reserve(unquoted_s.length());
for (size_t i = 0; i < unquoted_s.length(); ++i)
{
if (unquoted_s[i] == '\\' && i + 1 < unquoted_s.length())
{
switch (unquoted_s[i + 1])
{
case '"':
result += '"';
break;
case '\\':
result += '\\';
break;
case 'n':
result += '\n';
break;
case 't':
result += '\t';
break;
default:
result += unquoted_s[i + 1];
break;
}
i++;
}
else
{
result += unquoted_s[i];
}
}
return result;
}
return s;
}

static Value parseNumericOrBooleanLiteral(const std::string &s)
{
if (s == "true")
return true;
if (s == "false")
return false;

std::istringstream iss(s);
long long ll_val;
if (iss >> ll_val && iss.eof())
{
return ll_val;
}

iss.clear();
iss.str(s);
double d_val;
if (iss >> d_val && iss.eof())
{
return d_val;
}
return std::monostate{};
}

static ParameterDefinition parseParameterLine(Evaluator &eval, const std::string &line)
{
ParameterDefinition def;
std::string param_str = line.substr(line.find('=') + 1);
param_str = std::regex_replace(param_str, std::regex("^\\s+|\\s+$"), "");

std::regex required_regex("<(string|integer|number|boolean)>");
std::regex optional_regex("\\[([^\\]]+)\\]");

std::smatch match;

if (std::regex_match(param_str, match, required_regex))
{
def.kind = ParameterKind::REQUIRED;
def.config_value_str = match[1].str();
if (def.config_value_str == "string")
def.expected_type = DeclaredType::STRING;
else if (def.config_value_str == "integer")
def.expected_type = DeclaredType::INTEGER;
else if (def.config_value_str == "number")
def.expected_type = DeclaredType::NUMBER;
else if (def.config_value_str == "boolean")
def.expected_type = DeclaredType::BOOLEAN;
else
throw std::runtime_error("Unknown type in required parameter: " + def.config_value_str);
}
else if (std::regex_match(param_str, match, optional_regex))
{
def.kind = ParameterKind::OPTIONAL;
def.config_value_str = match[1].str();

def.resolved_value = parseLiteralString(def.config_value_str);
if (std::holds_alternative<std::string>(def.resolved_value) && std::get<std::string>(def.resolved_value) == def.config_value_str)
{
def.resolved_value = parseNumericOrBooleanLiteral(def.config_value_str);
}

if (std::holds_alternative<std::monostate>(def.resolved_value))
{
try
{
def.resolved_value = eval.getConstant(def.config_value_str);
}
catch (const std::runtime_error &e)
{
throw std::runtime_error("Helper config error: Optional parameter default '" + def.config_value_str + "' is not a valid literal or constant: " + e.what());
}
}
}
else
{
def.kind = ParameterKind::FIXED;
def.config_value_str = param_str;

def.resolved_value = parseLiteralString(def.config_value_str);
if (std::holds_alternative<std::string>(def.resolved_value) && std::get<std::string>(def.resolved_value) == def.config_value_str)
{
def.resolved_value = parseNumericOrBooleanLiteral(def.config_value_str);
}

if (std::holds_alternative<std::monostate>(def.resolved_value))
{
try
{
def.resolved_value = eval.getConstant(def.config_value_str);
}
catch (const std::runtime_error &e)
{
throw std::runtime_error("Helper config error: Fixed parameter value '" + def.config_value_str + "' is not a valid literal or constant: " + e.what());
}
}
}
return def;
}

static HelperDefinition loadIndividualHelperConfig(Evaluator &eval, const fs::path &config_file_path)
{
std::ifstream file(config_file_path);
if (!file.is_open())
{
throw std::runtime_error("Could not open helper config file: " + config_file_path.string());
}

HelperDefinition helper_def;
std::string line;

while (std::getline(file, line))
{
if (line.empty() || line.find_first_not_of(" \t\n\r") == std::string::npos)
continue;

size_t eq_pos = line.find('=');
if (eq_pos == std::string::npos)
{
throw std::runtime_error("Invalid line in helper config '" + config_file_path.string() + "': " + line + ". Expected 'key=value'.");
}

std::string key = line.substr(0, eq_pos);
key = std::regex_replace(key, std::regex("^\\s+|\\s+$"), "");

if (key == "name")
{
helper_def.helper_name = line.substr(eq_pos + 1);
helper_def.helper_name = std::regex_replace(helper_def.helper_name, std::regex("^\\s+|\\s+$"), "");
}
else if (key == "extension")
{
helper_def.extension_name = line.substr(eq_pos + 1);
helper_def.extension_name = std::regex_replace(helper_def.extension_name, std::regex("^\\s+|\\s+$"), "");
}
else if (key.rfind("parameter_", 0) == 0)
{
helper_def.parameters.push_back(parseParameterLine(eval, line));
}
else
{
std::cerr << "Warning: Unknown key '" << key << "' in helper config file: " << config_file_path.string() << std::endl;
}
}

if (helper_def.helper_name.empty())
{
throw std::runtime_error("Helper config '" + config_file_path.string() + "' is missing 'name' field.");
}
if (helper_def.extension_name.empty())
{
throw std::runtime_error("Helper config '" + config_file_path.string() + "' is missing 'extension' field.");
}

return helper_def;
}

static std::vector<HelperDefinition> loadHelperDefinitions(Evaluator &eval, const std::string &system_helpers_dir)
{
std::vector<HelperDefinition> definitions;
fs::path helpers_path = system_helpers_dir;

if (!fs::exists(helpers_path) || !fs::is_directory(helpers_path))
{
throw std::runtime_error("System helpers directory not found: " + helpers_path.string());
}

for (const auto &entry : fs::directory_iterator(helpers_path))
{
if (entry.is_regular_file() && entry.path().extension() == ".config")
{
HelperDefinition def = loadIndividualHelperConfig(eval, entry.path());
definitions.push_back(def);
}
}
return definitions;
}

void registerAllHelpers(Evaluator &eval)
{
std::vector<HelperDefinition> helper_defs = loadHelperDefinitions(eval, "src/helpers/system");

for (const auto &h_def : helper_defs)
{
eval.registerNativeFunction(h_def.helper_name,
[&eval, h_def](const std::vector<Value> &user_args) -> Value
{
std::vector<Value> extension_args;
size_t user_arg_idx = 0;
size_t required_count = 0;
size_t optional_count = 0;

for (const auto &param_def : h_def.parameters)
{
if (param_def.kind == ParameterKind::REQUIRED)
{
required_count++;
}
else if (param_def.kind == ParameterKind::OPTIONAL)
{
optional_count++;
}
}

if (user_args.size() < required_count || user_args.size() > (required_count + optional_count))
{
std::stringstream ss;
ss << "Helper '" << h_def.helper_name << "' expects between " << required_count << " and " << (required_count + optional_count) << " arguments, but received " << user_args.size() << ".";
throw std::runtime_error(ss.str());
}

for (const auto &param_def : h_def.parameters)
{
if (param_def.kind == ParameterKind::REQUIRED)
{
if (user_arg_idx >= user_args.size())
{
throw std::runtime_error("Internal error: Missing required argument for helper '" + h_def.helper_name + "'.");
}
if (param_def.expected_type == DeclaredType::STRING)
{
extension_args.push_back(get_string_arg(user_args, user_arg_idx, h_def.helper_name, "user_arg_" + std::to_string(user_arg_idx + 1)));
}
else if (param_def.expected_type == DeclaredType::INTEGER)
{
extension_args.push_back(get_integer_arg(user_args, user_arg_idx, h_def.helper_name, "user_arg_" + std::to_string(user_arg_idx + 1)));
}
else if (param_def.expected_type == DeclaredType::NUMBER)
{
extension_args.push_back(get_number_arg(user_args, user_arg_idx, h_def.helper_name, "user_arg_" + std::to_string(user_arg_idx + 1)));
}
else if (param_def.expected_type == DeclaredType::BOOLEAN)
{
if (!std::holds_alternative<bool>(user_args[user_arg_idx]))
{
throw std::runtime_error("Helper '" + h_def.helper_name + "': Argument " + std::to_string(user_arg_idx + 1) + " must be a boolean.");
}
extension_args.push_back(user_args[user_arg_idx]);
}
user_arg_idx++;
}
else if (param_def.kind == ParameterKind::OPTIONAL)
{
if (user_arg_idx < user_args.size())
{
extension_args.push_back(user_args[user_arg_idx]);
user_arg_idx++;
}
else
{
extension_args.push_back(param_def.resolved_value);
}
}
else
{
extension_args.push_back(param_def.resolved_value);
}
}

return eval.callNativeFunctionByName(h_def.extension_name, extension_args);
});
}
}
# /mcl/.prep_ai/../src/core/lexer.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef LEXER_H
#define LEXER_H

#include <string>
#include <vector>
#include "token.h"

class Lexer
{
private:
std::string source;
int current;
int line;

char peek();
char advance();
char peekNext();
void skipWhitespace();

Token identifierOrKeyword();
Token string();
Token number();

public:
Lexer(std::string source);
Token getNextToken();
};

#endif
# /mcl/.prep_ai/../src/core/ast.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef AST_H
#define AST_H

#include <memory>
#include <string>
#include <vector>
#include "token.h"
#include "value.h"

struct ASTNode
{
virtual ~ASTNode() = default;
};

struct StringLiteralExpr : public ASTNode
{
std::string value;
StringLiteralExpr(std::string val) : value(std::move(val)) {}
};

struct NumberLiteralExpr : public ASTNode
{
double value;
NumberLiteralExpr(double val) : value(val) {}
};

struct BooleanLiteralExpr : public ASTNode
{
bool value;
BooleanLiteralExpr(bool val) : value(val) {}
};

struct VariableExpr : public ASTNode
{
std::string name;
VariableExpr(std::string name) : name(std::move(name)) {}
};

struct BinaryOpExpr : public ASTNode
{
TokenType op;
std::unique_ptr<ASTNode> left;
std::unique_ptr<ASTNode> right;

BinaryOpExpr(TokenType op_type, std::unique_ptr<ASTNode> left_expr, std::unique_ptr<ASTNode> right_expr)
: op(op_type), left(std::move(left_expr)), right(std::move(right_expr)) {}
};

struct UnaryOpExpr : public ASTNode
{
TokenType op;
std::unique_ptr<ASTNode> right;

UnaryOpExpr(TokenType op_type, std::unique_ptr<ASTNode> right_expr)
: op(op_type), right(std::move(right_expr)) {}
};

struct CallExpr : public ASTNode
{
std::unique_ptr<ASTNode> callee;
std::vector<std::unique_ptr<ASTNode>> arguments;

CallExpr(std::unique_ptr<ASTNode> callee_expr, std::vector<std::unique_ptr<ASTNode>> args)
: callee(std::move(callee_expr)), arguments(std::move(args)) {}
};

struct AssignmentStatement : public ASTNode
{
std::unique_ptr<VariableExpr> target;
std::unique_ptr<ASTNode> value;
bool is_declaration;

AssignmentStatement(std::unique_ptr<VariableExpr> target_var, std::unique_ptr<ASTNode> assigned_value, bool is_decl = false)
: target(std::move(target_var)), value(std::move(assigned_value)), is_declaration(is_decl) {}
};

struct DeclarationStatement : public ASTNode
{
TokenType declared_type;
std::unique_ptr<VariableExpr> target;
std::unique_ptr<ASTNode> value;

DeclarationStatement(TokenType type, std::unique_ptr<VariableExpr> target_var, std::unique_ptr<ASTNode> initial_value)
: declared_type(type), target(std::move(target_var)), value(std::move(initial_value)) {}
};

struct EchoStatement : public ASTNode
{
std::unique_ptr<ASTNode> expression;

EchoStatement(std::unique_ptr<ASTNode> expr_to_echo) : expression(std::move(expr_to_echo)) {}
};

struct ProgramNode : public ASTNode
{
std::vector<std::unique_ptr<ASTNode>> statements;
ProgramNode() = default;
};

#endif
# /mcl/.prep_ai/../src/core/parser.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "parser.h"
#include <iostream>
#include <string>
#include <stdexcept>

Parser::Parser(Lexer &lexer) : lexer(lexer), currentToken(lexer.getNextToken())
{
}

void Parser::advance()
{
currentToken = lexer.getNextToken();

if (currentToken.type == TokenType::UNKNOWN)
{
throw std::runtime_error("Lexer returned UNKNOWN token: \"" + currentToken.lexeme + "\" at line " + std::to_string(currentToken.line) + ".");
}
}

void Parser::consume(TokenType type)
{
if (currentToken.type == type)
{
advance();
}
else
{
throw std::runtime_error("Expected token type " + Token(type, "", 0).toString() + " but found " + currentToken.toString() + ".");
}
}

std::unique_ptr<ASTNode> Parser::parsePrimaryExpression()
{
if (currentToken.type == TokenType::STRING_LITERAL)
{
std::string value = std::get<std::string>(currentToken.literal);
consume(TokenType::STRING_LITERAL);
return std::make_unique<StringLiteralExpr>(value);
}
else if (currentToken.type == TokenType::NUMBER_LITERAL)
{
double value;
if (std::holds_alternative<long long>(currentToken.literal))
{
value = static_cast<double>(std::get<long long>(currentToken.literal));
}
else
{
value = std::get<double>(currentToken.literal);
}
consume(TokenType::NUMBER_LITERAL);
return std::make_unique<NumberLiteralExpr>(value);
}
else if (currentToken.type == TokenType::TRUE)
{
bool value = std::get<bool>(currentToken.literal);
consume(TokenType::TRUE);
return std::make_unique<BooleanLiteralExpr>(value);
}
else if (currentToken.type == TokenType::FALSE)
{
bool value = std::get<bool>(currentToken.literal);
consume(TokenType::FALSE);
return std::make_unique<BooleanLiteralExpr>(value);
}
else if (currentToken.type == TokenType::IDENTIFIER)
{
std::string name = currentToken.lexeme;
consume(TokenType::IDENTIFIER);
return std::make_unique<VariableExpr>(name);
}
else if (currentToken.type == TokenType::LEFT_PAREN)
{
consume(TokenType::LEFT_PAREN);
std::unique_ptr<ASTNode> expr = parseExpression();
consume(TokenType::RIGHT_PAREN);
return expr;
}

throw std::runtime_error("Expected a primary expression (literal, variable, or parenthesized expression), but got " +
currentToken.toString() + " at line " + std::to_string(currentToken.line) + ".");
}

std::unique_ptr<ASTNode> Parser::parseCall()
{
std::unique_ptr<ASTNode> expr = parsePrimaryExpression();

while (currentToken.type == TokenType::LEFT_PAREN)
{
consume(TokenType::LEFT_PAREN);
std::vector<std::unique_ptr<ASTNode>> args;
if (currentToken.type != TokenType::RIGHT_PAREN)
{
do
{
args.push_back(parseExpression());
if (currentToken.type == TokenType::COMMA)
{
consume(TokenType::COMMA);
}
else
{
break;
}
} while (true);
}
consume(TokenType::RIGHT_PAREN);
expr = std::make_unique<CallExpr>(std::move(expr), std::move(args));
}
return expr;
}

std::unique_ptr<ASTNode> Parser::parseUnary()
{
if (currentToken.type == TokenType::BANG ||
currentToken.type == TokenType::MINUS ||
currentToken.type == TokenType::NOT)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseUnary();
return std::make_unique<UnaryOpExpr>(op, std::move(right));
}
return parseCall();
}

std::unique_ptr<ASTNode> Parser::parseFactor()
{
std::unique_ptr<ASTNode> left = parseUnary();

while (currentToken.type == TokenType::STAR || currentToken.type == TokenType::SLASH)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseUnary();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseTerm()
{
std::unique_ptr<ASTNode> left = parseFactor();

while (currentToken.type == TokenType::PLUS || currentToken.type == TokenType::MINUS)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseFactor();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseComparison()
{
std::unique_ptr<ASTNode> left = parseTerm();

while (currentToken.type == TokenType::GREATER || currentToken.type == TokenType::GREATER_EQUAL ||
currentToken.type == TokenType::LESS || currentToken.type == TokenType::LESS_EQUAL)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseTerm();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseEquality()
{
std::unique_ptr<ASTNode> left = parseComparison();

while (currentToken.type == TokenType::BANG_EQUAL || currentToken.type == TokenType::EQUAL_EQUAL)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseComparison();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseBitwiseOr()
{
std::unique_ptr<ASTNode> left = parseEquality();

while (currentToken.type == TokenType::PIPE)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseEquality();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseLogicalAnd()
{
std::unique_ptr<ASTNode> left = parseBitwiseOr();

while (currentToken.type == TokenType::AND)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseBitwiseOr();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseLogicalOr()
{
std::unique_ptr<ASTNode> left = parseLogicalAnd();

while (currentToken.type == TokenType::OR)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseLogicalAnd();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseConcatenation()
{
std::unique_ptr<ASTNode> left = parseLogicalOr();

while (currentToken.type == TokenType::DOT)
{
TokenType op = currentToken.type;
advance();
std::unique_ptr<ASTNode> right = parseLogicalOr();
left = std::make_unique<BinaryOpExpr>(op, std::move(left), std::move(right));
}
return left;
}

std::unique_ptr<ASTNode> Parser::parseExpression()
{
return parseConcatenation();
}

std::unique_ptr<ASTNode> Parser::parseStatement()
{
if (currentToken.type == TokenType::ECHO)
{
consume(TokenType::ECHO);
std::unique_ptr<ASTNode> expr = parseExpression();
consume(TokenType::SEMICOLON);
return std::make_unique<EchoStatement>(std::move(expr));
}
else if (currentToken.type == TokenType::PUBLIC)
{
consume(TokenType::PUBLIC);
TokenType declared_type_token = currentToken.type;

if (declared_type_token != TokenType::STRING_KEYWORD &&
declared_type_token != TokenType::INTEGER_KEYWORD &&
declared_type_token != TokenType::NUMBER_KEYWORD &&
declared_type_token != TokenType::BOOLEAN_KEYWORD)
{
throw std::runtime_error("Expected a type keyword (string, integer, number, boolean) after 'public', but got " +
currentToken.toString() + " at line " + std::to_string(currentToken.line) + ".");
}
consume(declared_type_token);

std::unique_ptr<VariableExpr> var_target = std::make_unique<VariableExpr>(currentToken.lexeme);
consume(TokenType::IDENTIFIER);

std::unique_ptr<ASTNode> value_expr = nullptr;
if (currentToken.type == TokenType::EQUAL)
{
consume(TokenType::EQUAL);
value_expr = parseExpression();
}

consume(TokenType::SEMICOLON);
return std::make_unique<DeclarationStatement>(declared_type_token, std::move(var_target), std::move(value_expr));
}
else if (currentToken.type == TokenType::IDENTIFIER)
{
std::unique_ptr<VariableExpr> var_target = std::make_unique<VariableExpr>(currentToken.lexeme);
consume(TokenType::IDENTIFIER);
consume(TokenType::EQUAL);
std::unique_ptr<ASTNode> value_expr = parseExpression();
consume(TokenType::SEMICOLON);
return std::make_unique<AssignmentStatement>(std::move(var_target), std::move(value_expr), false);
}

throw std::runtime_error("Unexpected token at the beginning of a statement: " +
currentToken.toString() + " at line " + std::to_string(currentToken.line) + ".");
}

std::unique_ptr<ProgramNode> Parser::parseProgram()
{
auto program = std::make_unique<ProgramNode>();

while (currentToken.type != TokenType::EOF_TOKEN)
{
program->statements.push_back(parseStatement());
}
return program;
}
# /mcl/.prep_ai/../src/core/debugger.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef MCL_DEBUGGER_H
#define MCL_DEBUGGER_H

#include <string>
#include <memory>
#include "ast.h"




#ifdef ENABLE_DEBUG_OUTPUT

void debug_print_message(const std::string &msg);
void debug_print_ast_header(const std::string &title);
void debug_print_ast_node(const ASTNode *node, int indent = 0);
void debug_print_ast_footer();

#else

inline void debug_print_message(const std::string &msg) {}
inline void debug_print_ast_header(const std::string &title) {}
inline void debug_print_ast_node(const ASTNode *node, int indent = 0) {}
inline void debug_print_ast_footer() {}

#endif

#endif
# /mcl/.prep_ai/../src/core/value.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef VALUE_H
#define VALUE_H

#include <string>
#include <variant>
#include <iostream>
#include <iomanip>
#include <sstream>
#include <cmath>

enum class DeclaredType
{
ANY,
STRING,
INTEGER,
NUMBER,
BOOLEAN
};

inline DeclaredType valueTypeToDeclaredType(const std::variant<std::string, long long, double, bool, std::monostate> &val)
{
if (std::holds_alternative<std::string>(val))
return DeclaredType::STRING;
if (std::holds_alternative<long long>(val))
return DeclaredType::INTEGER;
if (std::holds_alternative<double>(val))
return DeclaredType::NUMBER;
if (std::holds_alternative<bool>(val))
return DeclaredType::BOOLEAN;
return DeclaredType::ANY;
}

using Value = std::variant<std::string, long long, double, bool, std::monostate>;

inline std::ostream &operator<<(std::ostream &os, const Value &val)
{
if (std::holds_alternative<std::string>(val))
{
os << std::get<std::string>(val);
}
else if (std::holds_alternative<long long>(val))
{
os << std::get<long long>(val);
}
else if (std::holds_alternative<double>(val))
{
std::stringstream ss;
ss << std::setprecision(14) << std::get<double>(val);
os << ss.str();
}
else if (std::holds_alternative<bool>(val))
{
os << (std::get<bool>(val) ? "true" : "false");
}
else if (std::holds_alternative<std::monostate>(val))
{
os << "null";
}
return os;
}

#endif
# /mcl/.prep_ai/../src/core/constants.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef MCL_CONSTANTS_H
#define MCL_CONSTANTS_H

#include "../extensions/pad/pad_constants.h"
#include "../extensions/trim/trim_constants.h"
#include "../extensions/uppercase/uppercase_constants.h"
#include "../extensions/wrap/wrap_constants.h"

#endif
# /mcl/.prep_ai/../src/core/token.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef TOKEN_H
#define TOKEN_H

#include <string>
#include <variant>
#include <utility>
#include <cstdint>

#include "value.h"

enum class TokenType
{
SEMICOLON,
DOT,
EQUAL,
LEFT_PAREN,
RIGHT_PAREN,
PLUS,
MINUS,
STAR,
SLASH,
BANG,
LESS,
GREATER,

BANG_EQUAL,
EQUAL_EQUAL,
LESS_EQUAL,
GREATER_EQUAL,

IDENTIFIER,
STRING_LITERAL,
NUMBER_LITERAL,
TRUE,
FALSE,

ECHO,
AND,
OR,
NOT,

PUBLIC,
STRING_KEYWORD,
INTEGER_KEYWORD,
NUMBER_KEYWORD,
BOOLEAN_KEYWORD,

COMMA,
PIPE,

EOF_TOKEN,
UNKNOWN,
};

inline DeclaredType tokenTypeToDeclaredType(TokenType type)
{
switch (type)
{
case TokenType::STRING_KEYWORD:
return DeclaredType::STRING;
case TokenType::INTEGER_KEYWORD:
return DeclaredType::INTEGER;
case TokenType::NUMBER_KEYWORD:
return DeclaredType::NUMBER;
case TokenType::BOOLEAN_KEYWORD:
return DeclaredType::BOOLEAN;
default:
return DeclaredType::ANY;
}
}

struct Token
{
TokenType type;
std::string lexeme;
std::variant<std::string, long long, double, bool, std::monostate> literal;
int line;

Token(TokenType type, std::string lexeme, std::variant<std::string, long long, double, bool, std::monostate> literal, int line)
: type(type), lexeme(std::move(lexeme)), literal(std::move(literal)), line(line) {}

Token(TokenType type, std::string lexeme, int line)
: type(type), lexeme(std::move(lexeme)), literal(std::monostate{}), line(line) {}

std::string toString() const;
};

#endif
# /mcl/.prep_ai/../src/core/debugger.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "debugger.h"
#include <iostream>
#include <string>
#include "token.h"

#ifdef ENABLE_DEBUG_OUTPUT

void printIndent(int indent)
{
for (int i = 0; i < indent; ++i)
{
std::cout << "  ";
}
}

void debug_print_message(const std::string &msg)
{
std::cout << msg << std::endl;
}

void debug_print_ast_header(const std::string &title)
{
std::cout << "\n--- " << title << " ---" << std::endl;
}

void debug_print_ast_node(const ASTNode *node, int indent)
{
if (!node)
{
return;
}

printIndent(indent);

if (auto *prog = dynamic_cast<const ProgramNode *>(node))
{
std::cout << "ProgramNode (" << prog->statements.size() << " statements)\n";
for (const auto &stmt : prog->statements)
{
debug_print_ast_node(stmt.get(), indent + 1);
}
}
else if (auto *decl = dynamic_cast<const DeclarationStatement *>(node))
{
std::cout << "DeclarationStatement (Type: " << Token(decl->declared_type, "", 0).toString() << ", Target: " << decl->target->name << ")\n";
if (decl->value)
{
debug_print_ast_node(decl->value.get(), indent + 1);
}
else
{
printIndent(indent + 1);
std::cout << "Initial Value: None\n";
}
}
else if (auto *assign = dynamic_cast<const AssignmentStatement *>(node))
{
std::cout << "AssignmentStatement (Target: " << assign->target->name << ")\n";
debug_print_ast_node(assign->value.get(), indent + 1);
}
else if (auto *echo = dynamic_cast<const EchoStatement *>(node))
{
std::cout << "EchoStatement\n";
debug_print_ast_node(echo->expression.get(), indent + 1);
}
else if (auto *strLit = dynamic_cast<const StringLiteralExpr *>(node))
{
std::cout << "StringLiteralExpr: \"" << strLit->value << "\"\n";
}
else if (auto *numLit = dynamic_cast<const NumberLiteralExpr *>(node))
{
std::cout << "NumberLiteralExpr: " << numLit->value << "\n";
}
else if (auto *boolLit = dynamic_cast<const BooleanLiteralExpr *>(node))
{
std::cout << "BooleanLiteralExpr: " << (boolLit->value ? "true" : "false") << "\n";
}
else if (auto *var = dynamic_cast<const VariableExpr *>(node))
{
std::cout << "VariableExpr: " << var->name << "\n";
}
else if (auto *binOp = dynamic_cast<const BinaryOpExpr *>(node))
{
std::cout << "BinaryOpExpr (Op: " << Token(binOp->op, "", 0).toString() << ")\n";
debug_print_ast_node(binOp->left.get(), indent + 1);
debug_print_ast_node(binOp->right.get(), indent + 1);
}
else if (auto *unaryOp = dynamic_cast<const UnaryOpExpr *>(node))
{
std::cout << "UnaryOpExpr (Op: " << Token(unaryOp->op, "", 0).toString() << ")\n";
debug_print_ast_node(unaryOp->right.get(), indent + 1);
}
else if (auto *call = dynamic_cast<const CallExpr *>(node))
{
std::cout << "CallExpr\n";
printIndent(indent + 1);
std::cout << "Callee:\n";
debug_print_ast_node(call->callee.get(), indent + 2);
printIndent(indent + 1);
std::cout << "Arguments (" << call->arguments.size() << "):\n";
for (const auto &arg : call->arguments)
{
debug_print_ast_node(arg.get(), indent + 2);
}
}
else
{
std::cout << "Unknown AST Node Type\n";
}
}

void debug_print_ast_footer()
{
std::cout << "----------------------------------\n\n";
}

#endif
# /mcl/.prep_ai/../src/core/evaluator.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef EVALUATOR_H
#define EVALUATOR_H

#include <string>
#include <memory>
#include <vector>
#include <map>
#include "ast.h"
#include "value.h"
#include <functional>
#include <stdexcept>

using NativeFunction = std::function<Value(const std::vector<Value> &)>;

class Evaluator
{
private:
std::map<std::string, std::pair<Value, DeclaredType>> variables;
std::map<std::string, NativeFunction> nativeFunctions;

Value evaluate(ASTNode *node);
Value evaluateProgramNode(ProgramNode *node);
Value evaluateDeclarationStatement(DeclarationStatement *node);
Value evaluateAssignmentStatement(AssignmentStatement *node);
Value evaluateEchoStatement(EchoStatement *node);
Value evaluateStringLiteralExpr(StringLiteralExpr *node);
Value evaluateNumberLiteralExpr(NumberLiteralExpr *node);
Value evaluateBooleanLiteralExpr(BooleanLiteralExpr *node);
Value evaluateVariableExpr(VariableExpr *node);
Value evaluateBinaryOpExpr(BinaryOpExpr *node);
Value evaluateUnaryOpExpr(UnaryOpExpr *node);
Value evaluateCallExpr(CallExpr *node);

Value performNumericBinaryOp(const Value &left, const Value &right, TokenType op);
Value performBooleanBinaryOp(const Value &left, const Value &right, TokenType op);
bool convertToBool(const Value &val);
void enforceType(const std::string &var_name, DeclaredType declared_type, const Value &assigned_value);

public:
Evaluator();
void registerNativeFunction(const std::string &name, NativeFunction func);
void registerConstant(const std::string &name, Value value);
void interpret(std::unique_ptr<ProgramNode> ast);
Value callNativeFunctionByName(const std::string &name, const std::vector<Value> &args);
Value getConstant(const std::string &name);
};

#endif
# /mcl/.prep_ai/../src/core/parser.h # NOT PART OF CODE DON'T ECHO IT EVER #
#ifndef PARSER_H
#define PARSER_H

#include <vector>
#include <string>
#include <memory>
#include "lexer.h"
#include "ast.h"
#include "token.h"

class Parser
{
private:
Lexer &lexer;
Token currentToken;

void advance();
void consume(TokenType type);

std::unique_ptr<ASTNode> parseStatement();
std::unique_ptr<ASTNode> parseExpression();
std::unique_ptr<ASTNode> parseLogicalOr();
std::unique_ptr<ASTNode> parseLogicalAnd();
std::unique_ptr<ASTNode> parseBitwiseOr();
std::unique_ptr<ASTNode> parseEquality();
std::unique_ptr<ASTNode> parseComparison();
std::unique_ptr<ASTNode> parseTerm();
std::unique_ptr<ASTNode> parseFactor();
std::unique_ptr<ASTNode> parseUnary();
std::unique_ptr<ASTNode> parseCall();
std::unique_ptr<ASTNode> parseConcatenation();
std::unique_ptr<ASTNode> parsePrimaryExpression();

public:
Parser(Lexer &lexer);

std::unique_ptr<ProgramNode> parseProgram();
};

#endif
# /mcl/.prep_ai/../src/core/evaluator.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "evaluator.h"
#include <iostream>
#include <stdexcept>
#include <cmath>
#include <sstream>
#include <variant>
#include <limits>

bool Evaluator::convertToBool(const Value &val)
{
return std::visit([](auto &&arg) -> bool
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, std::string>) {
return !arg.empty();
} else if constexpr (std::is_same_v<T, long long>) {
return arg != 0LL;
} else if constexpr (std::is_same_v<T, double>) {
return arg != 0.0;
} else if constexpr (std::is_same_v<T, bool>) {
return arg;
} else if constexpr (std::is_same_v<T, std::monostate>) {
return false;
} else {
throw std::runtime_error("Internal error: convertToBool received unsupported type.");
} }, val);
}

Value Evaluator::performNumericBinaryOp(const Value &left_val, const Value &right_val, TokenType op)
{
long long left_ll = 0;
bool left_is_ll_candidate = false;
if (std::holds_alternative<long long>(left_val))
{
left_ll = std::get<long long>(left_val);
left_is_ll_candidate = true;
}
else if (std::holds_alternative<bool>(left_val))
{
left_ll = std::get<bool>(left_val) ? 1LL : 0LL;
left_is_ll_candidate = true;
}
else if (std::holds_alternative<double>(left_val))
{
left_is_ll_candidate = false;
}

long long right_ll = 0;
bool right_is_ll_candidate = false;
if (std::holds_alternative<long long>(right_val))
{
right_ll = std::get<long long>(right_val);
right_is_ll_candidate = true;
}
else if (std::holds_alternative<bool>(right_val))
{
right_ll = std::get<bool>(right_val) ? 1LL : 0LL;
right_is_ll_candidate = true;
}
else if (std::holds_alternative<double>(right_val))
{
right_is_ll_candidate = false;
}

if (left_is_ll_candidate && right_is_ll_candidate)
{
switch (op)
{
case TokenType::PLUS:
return left_ll + right_ll;
case TokenType::MINUS:
return left_ll - right_ll;
case TokenType::STAR:
return left_ll * right_ll;
case TokenType::SLASH:
if (right_ll == 0LL)
throw std::runtime_error("Runtime error: Integer division by zero.");
return left_ll / right_ll;
default:
break;
}
}

double left_double_val;
if (std::holds_alternative<double>(left_val))
left_double_val = std::get<double>(left_val);
else
left_double_val = static_cast<double>(left_ll);

double right_double_val;
if (std::holds_alternative<double>(right_val))
right_double_val = std::get<double>(right_val);
else
right_double_val = static_cast<double>(right_ll);

switch (op)
{
case TokenType::PLUS:
return left_double_val + right_double_val;
case TokenType::MINUS:
return left_double_val - right_double_val;
case TokenType::STAR:
return left_double_val * right_double_val;
case TokenType::SLASH:
if (right_double_val == 0.0)
throw std::runtime_error("Runtime error: Floating-point division by zero.");
return left_double_val / right_double_val;
case TokenType::GREATER:
return left_double_val > right_double_val;
case TokenType::GREATER_EQUAL:
return left_double_val >= right_double_val;
case TokenType::LESS:
return left_double_val < right_double_val;
case TokenType::LESS_EQUAL:
return left_double_val <= right_double_val;
default:
throw std::runtime_error("Unsupported numeric binary operator.");
}
}

Value Evaluator::performBooleanBinaryOp(const Value &left_val, const Value &right_val, TokenType op)
{
bool left_bool = convertToBool(left_val);
bool right_bool = convertToBool(right_val);

switch (op)
{
case TokenType::AND:
return left_bool && right_bool;
case TokenType::OR:
return left_bool || right_bool;
default:
throw std::runtime_error("Unsupported boolean binary operator.");
}
}

void Evaluator::enforceType(const std::string &var_name, DeclaredType declared_type, const Value &assigned_value)
{
DeclaredType actual_type = valueTypeToDeclaredType(assigned_value);

if (declared_type == DeclaredType::ANY)
{
return;
}

bool type_matches = false;
switch (declared_type)
{
case DeclaredType::STRING:
type_matches = (actual_type == DeclaredType::STRING);
break;
case DeclaredType::INTEGER:
type_matches = (actual_type == DeclaredType::INTEGER || actual_type == DeclaredType::BOOLEAN);
if (actual_type == DeclaredType::NUMBER)
{
double d_val = std::get<double>(assigned_value);
type_matches = (d_val == std::floor(d_val) && d_val >= std::numeric_limits<long long>::min() && d_val <= std::numeric_limits<long long>::max());
}
break;
case DeclaredType::NUMBER:
type_matches = (actual_type == DeclaredType::NUMBER || actual_type == DeclaredType::INTEGER || actual_type == DeclaredType::BOOLEAN);
break;
case DeclaredType::BOOLEAN:
type_matches = (actual_type == DeclaredType::BOOLEAN);
if (actual_type == DeclaredType::INTEGER)
{
long long ll_val = std::get<long long>(assigned_value);
type_matches = (ll_val == 0LL || ll_val == 1LL);
}
break;
default:
throw std::runtime_error("Internal error: Unknown declared type for variable '" + var_name + "'.");
}

if (!type_matches)
{
std::stringstream ss;
ss << "Type mismatch for variable '" << var_name << "'. Expected ";
switch (declared_type)
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
default:
ss << "unknown declared type";
break;
}
ss << ", but got value of type ";
switch (actual_type)
{
case DeclaredType::STRING:
ss << "string";
break;
case DeclaredType::INTEGER:
ss << "integer";
break;
case DeclaredType::NUMBER:
ss << "number";
break;
case DeclaredType::BOOLEAN:
ss << "boolean";
break;
case DeclaredType::ANY:
ss << "null";
break;
default:
ss << "unknown actual type";
break;
}
throw std::runtime_error(ss.str());
}
}

Evaluator::Evaluator()
{
}

void Evaluator::registerNativeFunction(const std::string &name, NativeFunction func)
{
nativeFunctions[name] = std::move(func);
}

void Evaluator::registerConstant(const std::string &name, Value value)
{
if (variables.count(name))
{
throw std::runtime_error("Internal error: Attempted to re-register existing constant/variable '" + name + "'.");
}

variables[name] = {value, valueTypeToDeclaredType(value)};
}

Value Evaluator::evaluate(ASTNode *node)
{
if (!node)
{
return std::monostate{};
}

if (auto *prog = dynamic_cast<ProgramNode *>(node))
{
return evaluateProgramNode(prog);
}
else if (auto *decl = dynamic_cast<DeclarationStatement *>(node))
{
return evaluateDeclarationStatement(decl);
}
else if (auto *assign = dynamic_cast<AssignmentStatement *>(node))
{
return evaluateAssignmentStatement(assign);
}
else if (auto *echo = dynamic_cast<EchoStatement *>(node))
{
return evaluateEchoStatement(echo);
}
else if (auto *strLit = dynamic_cast<StringLiteralExpr *>(node))
{
return evaluateStringLiteralExpr(strLit);
}
else if (auto *numLit = dynamic_cast<NumberLiteralExpr *>(node))
{
return evaluateNumberLiteralExpr(numLit);
}
else if (auto *boolLit = dynamic_cast<BooleanLiteralExpr *>(node))
{
return evaluateBooleanLiteralExpr(boolLit);
}
else if (auto *var = dynamic_cast<VariableExpr *>(node))
{
return evaluateVariableExpr(var);
}
else if (auto *binOp = dynamic_cast<BinaryOpExpr *>(node))
{
return evaluateBinaryOpExpr(binOp);
}
else if (auto *unaryOp = dynamic_cast<UnaryOpExpr *>(node))
{
return evaluateUnaryOpExpr(unaryOp);
}
else if (auto *call = dynamic_cast<CallExpr *>(node))
{
return evaluateCallExpr(call);
}
else
{
throw std::runtime_error("Unknown AST node type during evaluation.");
}
}

Value Evaluator::evaluateProgramNode(ProgramNode *node)
{
for (const auto &stmt : node->statements)
{
evaluate(stmt.get());
}
return std::monostate{};
}

Value Evaluator::evaluateDeclarationStatement(DeclarationStatement *node)
{
std::string var_name = node->target->name;
DeclaredType declared_type = tokenTypeToDeclaredType(node->declared_type);

if (variables.count(var_name))
{
throw std::runtime_error("Runtime error: Variable '" + var_name + "' already declared.");
}

Value initial_value_resolved = std::monostate{};
if (node->value)
{
initial_value_resolved = evaluate(node->value.get());
}

enforceType(var_name, declared_type, initial_value_resolved);
variables[var_name] = {initial_value_resolved, declared_type};
return initial_value_resolved;
}

Value Evaluator::evaluateAssignmentStatement(AssignmentStatement *node)
{
Value value = evaluate(node->value.get());
std::string var_name = node->target->name;

auto it = variables.find(var_name);
if (it == variables.end())
{
variables[var_name] = {value, DeclaredType::ANY};
}
else
{
DeclaredType declared_type = it->second.second;
enforceType(var_name, declared_type, value);
it->second.first = value;
}
return value;
}

Value Evaluator::evaluateEchoStatement(EchoStatement *node)
{
Value result = evaluate(node->expression.get());
std::cout << result << std::endl;
return std::monostate{};
}

Value Evaluator::evaluateStringLiteralExpr(StringLiteralExpr *node)
{
return node->value;
}

Value Evaluator::evaluateNumberLiteralExpr(NumberLiteralExpr *node)
{
return node->value;
}

Value Evaluator::evaluateBooleanLiteralExpr(BooleanLiteralExpr *node)
{
return node->value;
}

Value Evaluator::evaluateVariableExpr(VariableExpr *node)
{
auto it = variables.find(node->name);
if (it != variables.end())
{
return it->second.first;
}
else
{
throw std::runtime_error("Undefined variable: " + node->name);
}
}

Value Evaluator::evaluateCallExpr(CallExpr *node)
{
if (auto *callee_var = dynamic_cast<VariableExpr *>(node->callee.get()))
{
std::string function_name = callee_var->name;
auto it = nativeFunctions.find(function_name);
if (it == nativeFunctions.end())
{
throw std::runtime_error("Runtime error: Undefined function '" + function_name + "'.");
}

std::vector<Value> args;
for (const auto &arg_node : node->arguments)
{
args.push_back(evaluate(arg_node.get()));
}

return it->second(args);
}
else
{
throw std::runtime_error("Runtime error: Callee in function call is not a simple identifier.");
}
}

Value Evaluator::evaluateUnaryOpExpr(UnaryOpExpr *node)
{
Value right_val = evaluate(node->right.get());

if (node->op == TokenType::MINUS)
{
return std::visit([](auto &&arg) -> Value
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, long long>) {
return -arg;
} else if constexpr (std::is_same_v<T, double>) {
return -arg;
} else if constexpr (std::is_same_v<T, bool>) {
return static_cast<long long>(arg ? -1 : 0); 
} else {
throw std::runtime_error("Type error: Unary '-' operator can only be applied to numbers.");
} }, right_val);
}
else if (node->op == TokenType::BANG || node->op == TokenType::NOT)
{
return !convertToBool(right_val);
}
throw std::runtime_error("Unsupported unary operator.");
}

Value Evaluator::evaluateBinaryOpExpr(BinaryOpExpr *node)
{
Value left_val = evaluate(node->left.get());
Value right_val = evaluate(node->right.get());

if (node->op == TokenType::DOT)
{
std::string s_left, s_right;
std::visit([&](auto &&arg)
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, std::string>) {
s_left = arg;
} else {
std::stringstream ss;
ss << arg;
s_left = ss.str();
} }, left_val);
std::visit([&](auto &&arg)
{
using T = std::decay_t<decltype(arg)>;
if constexpr (std::is_same_v<T, std::string>) {
s_right = arg;
} else {
std::stringstream ss;
ss << arg;
s_right = ss.str();
} }, right_val);
return s_left + s_right;
}
else if (node->op == TokenType::PLUS || node->op == TokenType::MINUS ||
node->op == TokenType::STAR || node->op == TokenType::SLASH ||
node->op == TokenType::GREATER || node->op == TokenType::GREATER_EQUAL ||
node->op == TokenType::LESS || node->op == TokenType::LESS_EQUAL)
{

bool left_is_numeric_like = std::holds_alternative<long long>(left_val) || std::holds_alternative<double>(left_val) || std::holds_alternative<bool>(left_val);
bool right_is_numeric_like = std::holds_alternative<long long>(right_val) || std::holds_alternative<double>(right_val) || std::holds_alternative<bool>(right_val);

if (!left_is_numeric_like || !right_is_numeric_like)
{
throw std::runtime_error("Type error: Arithmetic/comparison operators can only be applied to numbers.");
}

return performNumericBinaryOp(left_val, right_val, node->op);
}
else if (node->op == TokenType::EQUAL_EQUAL || node->op == TokenType::BANG_EQUAL)
{

bool are_equal = std::visit([](auto &&l_arg, auto &&r_arg) -> bool
{

using L = std::decay_t<decltype(l_arg)>;
using R = std::decay_t<decltype(r_arg)>;

if constexpr (std::is_same_v<L, R>) {
if constexpr (std::is_same_v<L, std::string>) return l_arg == r_arg;
else if constexpr (std::is_same_v<L, long long>) return l_arg == r_arg;
else if constexpr (std::is_same_v<L, double>) return std::abs(l_arg - r_arg) < 0.000001; 
else if constexpr (std::is_same_v<L, bool>) return l_arg == r_arg;
else if constexpr (std::is_same_v<L, std::monostate>) return true; 
}


else if constexpr (
(std::is_same_v<L, long long> || std::is_same_v<L, double> || std::is_same_v<L, bool>) &&
(std::is_same_v<R, long long> || std::is_same_v<R, double> || std::is_same_v<R, bool>)
) {
double l_double, r_double;
if constexpr (std::is_same_v<L, long long>) l_double = static_cast<double>(l_arg);
else if constexpr (std::is_same_v<L, double>) l_double = l_arg;
else if constexpr (std::is_same_v<L, bool>) l_double = l_arg ? 1.0 : 0.0;
else l_double = 0.0; 

if constexpr (std::is_same_v<R, long long>) r_double = static_cast<double>(r_arg);
else if constexpr (std::is_same_v<R, double>) r_double = r_arg;
else if constexpr (std::is_same_v<R, bool>) r_double = r_arg ? 1.0 : 0.0;
else r_double = 0.0; 

return std::abs(l_double - r_double) < 0.000001;
}


return false; }, left_val, right_val);

return (node->op == TokenType::EQUAL_EQUAL) ? are_equal : !are_equal;
}
else if (node->op == TokenType::AND || node->op == TokenType::OR)
{

return performBooleanBinaryOp(left_val, right_val, node->op);
}
else if (node->op == TokenType::PIPE)
{
long long left_int_val;
long long right_int_val;

if (std::holds_alternative<long long>(left_val))
{
left_int_val = std::get<long long>(left_val);
}
else if (std::holds_alternative<double>(left_val))
{
double d_val = std::get<double>(left_val);
long long ll_val = static_cast<long long>(d_val);
if (d_val != static_cast<double>(ll_val))
{
throw std::runtime_error("Type error: Bitwise OR operator '|' requires integer operands. Left operand is a non-integer number.");
}
left_int_val = ll_val;
}
else if (std::holds_alternative<bool>(left_val))
{
left_int_val = std::get<bool>(left_val) ? 1LL : 0LL;
}
else
{
throw std::runtime_error("Type error: Bitwise OR operator '|' can only be applied to integer or number (convertible to integer) operands. Left operand is of invalid type.");
}

if (std::holds_alternative<long long>(right_val))
{
right_int_val = std::get<long long>(right_val);
}
else if (std::holds_alternative<double>(right_val))
{
double d_val = std::get<double>(right_val);
long long ll_val = static_cast<long long>(d_val);
if (d_val != static_cast<double>(ll_val))
{
throw std::runtime_error("Type error: Bitwise OR operator '|' requires integer operands. Right operand is a non-integer number.");
}
right_int_val = ll_val;
}
else if (std::holds_alternative<bool>(right_val))
{
right_int_val = std::get<bool>(right_val) ? 1LL : 0LL;
}
else
{
throw std::runtime_error("Type error: Bitwise OR operator '|' can only be applied to integer or number (convertible to integer) operands. Right operand is of invalid type.");
}

return left_int_val | right_int_val;
}

throw std::runtime_error("Unsupported binary operator.");
}

void Evaluator::interpret(std::unique_ptr<ProgramNode> ast)
{
evaluate(ast.get());
}

Value Evaluator::callNativeFunctionByName(const std::string &name, const std::vector<Value> &args)
{
auto it = nativeFunctions.find(name);
if (it == nativeFunctions.end())
{
throw std::runtime_error("Runtime error: Attempted to call unknown native function '" + name + "'.");
}
return it->second(args);
}

Value Evaluator::getConstant(const std::string &name)
{
auto it = variables.find(name);
if (it == variables.end())
{
throw std::runtime_error("Runtime error: Undefined constant '" + name + "'.");
}
return it->second.first;
}
# /mcl/.prep_ai/../src/core/token.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "token.h"
#include <map>
#include <string>
#include <iomanip>
#include <sstream>

static const std::map<TokenType, std::string> tokenTypeNames = {
{TokenType::SEMICOLON, "SEMICOLON"},
{TokenType::DOT, "DOT"},
{TokenType::EQUAL, "EQUAL"},
{TokenType::LEFT_PAREN, "LEFT_PAREN"},
{TokenType::RIGHT_PAREN, "RIGHT_PAREN"},
{TokenType::PLUS, "PLUS"},
{TokenType::MINUS, "MINUS"},
{TokenType::STAR, "STAR"},
{TokenType::SLASH, "SLASH"},
{TokenType::BANG, "BANG"},
{TokenType::LESS, "LESS"},
{TokenType::GREATER, "GREATER"},
{TokenType::BANG_EQUAL, "BANG_EQUAL"},
{TokenType::EQUAL_EQUAL, "EQUAL_EQUAL"},
{TokenType::LESS_EQUAL, "LESS_EQUAL"},
{TokenType::GREATER_EQUAL, "GREATER_EQUAL"},
{TokenType::IDENTIFIER, "IDENTIFIER"},
{TokenType::STRING_LITERAL, "STRING_LITERAL"},
{TokenType::NUMBER_LITERAL, "NUMBER_LITERAL"},
{TokenType::TRUE, "TRUE"},
{TokenType::FALSE, "FALSE"},
{TokenType::ECHO, "ECHO"},
{TokenType::AND, "AND"},
{TokenType::OR, "OR"},
{TokenType::NOT, "NOT"},
{TokenType::PUBLIC, "PUBLIC"},
{TokenType::STRING_KEYWORD, "STRING_KEYWORD"},
{TokenType::INTEGER_KEYWORD, "INTEGER_KEYWORD"},
{TokenType::NUMBER_KEYWORD, "NUMBER_KEYWORD"},
{TokenType::BOOLEAN_KEYWORD, "BOOLEAN_KEYWORD"},
{TokenType::COMMA, "COMMA"},
{TokenType::PIPE, "PIPE"},
{TokenType::EOF_TOKEN, "EOF_TOKEN"},
{TokenType::UNKNOWN, "UNKNOWN"},
};

std::string Token::toString() const
{
std::string typeName = tokenTypeNames.count(type) ? tokenTypeNames.at(type) : "UNKNOWN_TYPE";
std::string str = typeName + " (\"" + lexeme + "\")";

if (std::holds_alternative<std::string>(literal))
{
str += " -> \"" + std::get<std::string>(literal) + "\"";
}
else if (std::holds_alternative<long long>(literal))
{
str += " -> " + std::to_string(std::get<long long>(literal));
}
else if (std::holds_alternative<double>(literal))
{
std::stringstream ss;
ss << std::setprecision(14) << std::get<double>(literal);
str += " -> " + ss.str();
}
else if (std::holds_alternative<bool>(literal))
{
str += std::string(" -> ") + (std::get<bool>(literal) ? "true" : "false");
}

str += " at line " + std::to_string(line);

return str;
}
# /mcl/.prep_ai/../src/core/lexer.cpp # NOT PART OF CODE DON'T ECHO IT EVER #
#include "lexer.h"
#include <iostream>
#include <cctype>
#include <string>
#include <stdexcept>
#include <map>

static const std::map<std::string, TokenType> keywords = {
{"echo", TokenType::ECHO},
{"true", TokenType::TRUE},
{"false", TokenType::FALSE},
{"and", TokenType::AND},
{"or", TokenType::OR},
{"not", TokenType::NOT},
{"public", TokenType::PUBLIC},
{"string", TokenType::STRING_KEYWORD},
{"integer", TokenType::INTEGER_KEYWORD},
{"number", TokenType::NUMBER_KEYWORD},
{"boolean", TokenType::BOOLEAN_KEYWORD}};

Lexer::Lexer(std::string source) : source(std::move(source)), current(0), line(1) {}

char Lexer::peek()
{
if (current >= source.length())
{
return '\0';
}
return source[current];
}

char Lexer::peekNext()
{
if (current + 1 >= source.length())
{
return '\0';
}
return source[current + 1];
}

char Lexer::advance()
{
char c = '\0';
if (current < source.length())
{
c = source[current++];
if (c == '\n')
{
line++;
}
}
return c;
}

void Lexer::skipWhitespace()
{
while (true)
{
char c = peek();
if (c == ' ' || c == '\t' || c == '\n' || c == '\r')
{
advance();
continue;
}

if (c == '/')
{
if (peekNext() == '/')
{
advance();
advance();
while (peek() != '\n' && peek() != '\0')
{
advance();
}
continue;
}
else if (peekNext() == '*')
{
advance();
advance();
while (!(peek() == '*' && peekNext() == '/') && peek() != '\0')
{
advance();
}
if (peek() != '\0')
{
advance();
advance();
}
continue;
}
}
else if (c == '#')
{
advance();
while (peek() != '\n' && peek() != '\0')
{
advance();
}
continue;
}
break;
}
}

Token Lexer::identifierOrKeyword()
{
std::string lexeme;
int startLine = line;

if (peek() == '$')
{
lexeme += advance();
}

while (std::isalnum(peek()) || peek() == '_' || peek() == '-')
{
lexeme += advance();
}

if (lexeme.empty() || lexeme[0] != '$')
{
auto it = keywords.find(lexeme);
if (it != keywords.end())
{
if (it->second == TokenType::TRUE)
return Token(TokenType::TRUE, lexeme, true, startLine);
if (it->second == TokenType::FALSE)
return Token(TokenType::FALSE, lexeme, false, startLine);
return Token(it->second, lexeme, startLine);
}
}

return Token(TokenType::IDENTIFIER, lexeme, startLine);
}

Token Lexer::string()
{
int startLine = line;
advance();
std::string value;

while (peek() != '"' && peek() != '\0')
{
if (peek() == '\\')
{
advance();
char escaped_char = peek();
if (escaped_char == '\0')
{
throw std::runtime_error("Unterminated escape sequence in string literal at line " + std::to_string(startLine) + ".");
}

switch (escaped_char)
{
case '"':
value += '"';
break;
case '\\':
value += '\\';
break;
case 'n':
value += '\n';
break;
case 't':
value += '\t';
break;
default:
value += escaped_char;
break;
}
advance();
}
else
{
value += advance();
}
}

if (peek() == '\0')
{
throw std::runtime_error("Unterminated string literal at line " + std::to_string(startLine) + ".");
}

advance();

return Token(TokenType::STRING_LITERAL, "\"" + value + "\"", value, startLine);
}

Token Lexer::number()
{
std::string lexeme;
int startLine = line;
bool has_decimal = false;

while (std::isdigit(peek()))
{
lexeme += advance();
}

if (peek() == '.' && std::isdigit(peekNext()))
{
has_decimal = true;
lexeme += advance();

while (std::isdigit(peek()))
{
lexeme += advance();
}
}

if (has_decimal)
{
try
{
double value = std::stod(lexeme);
return Token(TokenType::NUMBER_LITERAL, lexeme, value, startLine);
}
catch (const std::out_of_range &)
{
throw std::runtime_error("Number literal out of range: " + lexeme + " at line " + std::to_string(startLine) + ".");
}
catch (const std::invalid_argument &)
{
throw std::runtime_error("Invalid number literal: " + lexeme + " at line " + std::to_string(startLine) + ".");
}
}
else
{
try
{
long long value = std::stoll(lexeme);
return Token(TokenType::NUMBER_LITERAL, lexeme, value, startLine);
}
catch (const std::out_of_range &)
{
throw std::runtime_error("Integer literal out of range: " + lexeme + " at line " + std::to_string(startLine) + ".");
}
catch (const std::invalid_argument &)
{
throw std::runtime_error("Invalid integer literal: " + lexeme + " at line " + std::to_string(startLine) + ".");
}
}
}

Token Lexer::getNextToken()
{
skipWhitespace();

char c = peek();
int startLine = line;

if (c == '\0')
{
return Token(TokenType::EOF_TOKEN, "", startLine);
}

switch (c)
{
case ';':
advance();
return Token(TokenType::SEMICOLON, ";", startLine);
case '.':
advance();
return Token(TokenType::DOT, ".", startLine);
case '(':
advance();
return Token(TokenType::LEFT_PAREN, "(", startLine);
case ')':
advance();
return Token(TokenType::RIGHT_PAREN, ")", startLine);
case '+':
advance();
return Token(TokenType::PLUS, "+", startLine);
case '-':
advance();
return Token(TokenType::MINUS, "-", startLine);
case '*':
advance();
return Token(TokenType::STAR, "*", startLine);
case '/':
advance();
return Token(TokenType::SLASH, "/", startLine);
case '!':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::BANG_EQUAL, "!=", startLine);
}
return Token(TokenType::BANG, "!", startLine);
}
case '=':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::EQUAL_EQUAL, "==", startLine);
}
return Token(TokenType::EQUAL, "=", startLine);
}
case '<':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::LESS_EQUAL, "<=", startLine);
}
return Token(TokenType::LESS, "<", startLine);
}
case '>':
{
advance();
if (peek() == '=')
{
advance();
return Token(TokenType::GREATER_EQUAL, ">=", startLine);
}
return Token(TokenType::GREATER, ">", startLine);
}
case '"':
return string();
case ',':
advance();
return Token(TokenType::COMMA, ",", startLine);
case '|':
advance();
return Token(TokenType::PIPE, "|", startLine);
case '$':
return identifierOrKeyword();
default:
if (std::isalpha(c))
{
return identifierOrKeyword();
}
if (std::isdigit(c))
{
return number();
}

throw std::runtime_error("Unexpected character '" + std::string(1, c) + "' at line " + std::to_string(startLine) + ".");
}
}
